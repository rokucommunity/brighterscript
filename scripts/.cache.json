{"https://developer.roku.com/api/v1/get-dev-cms-doc?filePath=left-nav%2Freferences.json&locale=en-us":"{\n  \"content\": \"{\\n  \\\"Reference overview\\\":\\\"/docs/references/references-overview.md\\\",\\n\\n  \\\"SceneGraph\\\":{\\n     \\\"Component functions\\\":{\\n        \\\"init()\\\":\\\"/docs/references/scenegraph/component-functions/init.md\\\",\\n        \\\"onKeyEvent()\\\":\\\"/docs/references/scenegraph/component-functions/onkeyevent.md\\\"\\n     },\\n     \\\"XML elements\\\":{\\n        \\\"<component>\\\":\\\"/docs/references/scenegraph/xml-elements/component.md\\\",\\n        \\\"<interface>\\\":\\\"/docs/references/scenegraph/xml-elements/interface.md\\\",\\n        \\\"<script>\\\":\\\"/docs/references/scenegraph/xml-elements/script.md\\\",\\n        \\\"<children>\\\":\\\"/docs/references/scenegraph/xml-elements/children.md\\\"\\n     },\\n     \\\"Abstract Nodes\\\":{\\n        \\\"Node\\\":\\\"/docs/references/scenegraph/abstract-nodes/node.md\\\",\\n        \\\"Scene\\\":\\\"/docs/references/scenegraph/abstract-nodes/scene.md\\\",\\n        \\\"AnimationBase\\\":\\\"/docs/references/scenegraph/abstract-nodes/animationbase.md\\\",\\n        \\\"ArrayGrid\\\":\\\"/docs/references/scenegraph/abstract-nodes/arraygrid.md\\\"\\n     },\\n     \\\"Renderable Nodes\\\":{\\n        \\\"Label\\\":\\\"/docs/references/scenegraph/renderable-nodes/label.md\\\",\\n        \\\"Poster\\\":\\\"/docs/references/scenegraph/renderable-nodes/poster.md\\\",\\n        \\\"Rectangle\\\":\\\"/docs/references/scenegraph/renderable-nodes/rectangle.md\\\",\\n        \\\"SimpleLabel\\\":\\\"/docs/references/scenegraph/renderable-nodes/simplelabel.md\\\"\\n     },\\n     \\\"Animation Nodes\\\":{\\n        \\\"Overview\\\":\\\"/docs/references/scenegraph/animation-nodes/overview.md\\\",\\n        \\\"Animation\\\":\\\"/docs/references/scenegraph/animation-nodes/animation.md\\\",\\n        \\\"SequentialAnimation\\\":\\\"/docs/references/scenegraph/animation-nodes/sequentialanimation.md\\\",\\n        \\\"ParallelAnimation\\\":\\\"/docs/references/scenegraph/animation-nodes/parallelanimation.md\\\",\\n        \\\"ColorFieldInterpolator\\\":\\\"/docs/references/scenegraph/animation-nodes/colorfieldinterpolator.md\\\",\\n        \\\"FloatFieldInterpolator\\\":\\\"/docs/references/scenegraph/animation-nodes/floatfieldinterpolator.md\\\",\\n        \\\"Vector2DfieldInterpolator\\\":\\\"/docs/references/scenegraph/animation-nodes/vector2dfieldinterpolator.md\\\"\\n     },\\n     \\\"Typographic Nodes\\\":{\\n        \\\"Overview\\\":\\\"/docs/references/scenegraph/typographic-nodes/overview.md\\\",\\n        \\\"Font\\\":\\\"/docs/references/scenegraph/typographic-nodes/font.md\\\",\\n        \\\"ScrollingLabel\\\":\\\"/docs/references/scenegraph/typographic-nodes/scrollinglabel.md\\\",\\n        \\\"ScrollableText\\\":\\\"/docs/references/scenegraph/typographic-nodes/scrollabletext.md\\\"\\n     },\\n     \\\"Control Nodes\\\":{\\n        \\\"ContentNode\\\":\\\"/docs/references/scenegraph/control-nodes/contentnode.md\\\",\\n        \\\"Task\\\":\\\"/docs/references/scenegraph/control-nodes/task.md\\\",\\n        \\\"MaskGroup\\\":\\\"/docs/references/scenegraph/control-nodes/maskgroup.md\\\",\\n        \\\"Timer\\\":\\\"/docs/references/scenegraph/control-nodes/timer.md\\\",\\n        \\\"ComponentLibrary\\\":\\\"/docs/references/scenegraph/control-nodes/componentlibrary.md\\\",\\n        \\\"ChannelStore\\\":\\\"/docs/references/scenegraph/control-nodes/channelstore.md\\\"\\n     },\\n     \\\"Layout/Group Nodes\\\":{\\n        \\\"Group\\\":\\\"/docs/references/scenegraph/layout-group-nodes/group.md\\\",\\n        \\\"ButtonGroup\\\":\\\"/docs/references/scenegraph/layout-group-nodes/buttongroup.md\\\",\\n        \\\"LayoutGroup\\\":\\\"/docs/references/scenegraph/layout-group-nodes/layoutgroup.md\\\",\\n        \\\"TargetGroup\\\":\\\"/docs/references/scenegraph/layout-group-nodes/targetgroup.md\\\"\\n     },\\n     \\\"Widget Nodes\\\":{\\n        \\\"Button\\\":\\\"/docs/references/scenegraph/widget-nodes/button.md\\\",\\n        \\\"TextEditBox\\\":\\\"/docs/references/scenegraph/widget-nodes/texteditbox.md\\\",\\n        \\\"Pinpad\\\":\\\"/docs/references/scenegraph/widget-nodes/pinpad.md\\\",\\n        \\\"Keyboard\\\":\\\"/docs/references/scenegraph/widget-nodes/keyboard.md\\\",\\n        \\\"MiniKeyboard\\\":\\\"/docs/references/scenegraph/widget-nodes/minikeyboard.md\\\",\\n        \\\"BusySpinner\\\":\\\"/docs/references/scenegraph/widget-nodes/busyspinner.md\\\",\\n        \\\"ParentalControlPinpad\\\":\\\"/docs/references/scenegraph/widget-nodes/parentalcontrolpinpad.md\\\"\\n     },\\n     \\\"Dialog Nodes\\\":{\\n        \\\"Dialog\\\":\\\"/docs/references/scenegraph/dialog-nodes/dialog.md\\\",\\n        \\\"KeyboardDialog\\\":\\\"/docs/references/scenegraph/dialog-nodes/keyboarddialog.md\\\",\\n        \\\"PinDialog\\\":\\\"/docs/references/scenegraph/dialog-nodes/pindialog.md\\\",\\n        \\\"ProgressDialog\\\":\\\"/docs/references/scenegraph/dialog-nodes/progressdialog.md\\\"\\n     },\\n     \\\"List and Grid Nodes\\\":{\\n        \\\"Overview\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/overview.md\\\",\\n        \\\"LabelList\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/labellist.md\\\",\\n        \\\"MarkupList\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/markuplist.md\\\",\\n        \\\"PosterGrid\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/postergrid.md\\\",\\n        \\\"MarkupGrid\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/markupgrid.md\\\",\\n        \\\"RowList\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/rowlist.md\\\",\\n        \\\"CheckList\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/checklist.md\\\",\\n        \\\"RadioButtonList\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/radiobuttonlist.md\\\",\\n        \\\"TargetList\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/targetlist.md\\\",\\n        \\\"TargetSet\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/targetset.md\\\",\\n        \\\"ZoomRowList\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/zoomrowlist.md\\\",\\n        \\\"TimeGrid\\\":\\\"/docs/references/scenegraph/list-and-grid-nodes/timegrid.md\\\"\\n     },\\n     \\\"Sliding Panel Nodes\\\":{\\n        \\\"Overview\\\":\\\"/docs/references/scenegraph/sliding-panels-nodes/overview.md\\\",\\n        \\\"OverhangPanelSetScene\\\":\\\"/docs/references/scenegraph/sliding-panels-nodes/overhangpanelsetscene.md\\\",\\n        \\\"Overhang\\\":\\\"/docs/references/scenegraph/sliding-panels-nodes/overhang.md\\\",\\n        \\\"PanelSet\\\":\\\"/docs/references/scenegraph/sliding-panels-nodes/panelset.md\\\",\\n        \\\"Panel\\\":\\\"/docs/references/scenegraph/sliding-panels-nodes/panel.md\\\",\\n        \\\"ListPanel\\\":\\\"/docs/references/scenegraph/sliding-panels-nodes/listpanel.md\\\",\\n        \\\"GridPanel\\\":\\\"/docs/references/scenegraph/sliding-panels-nodes/gridpanel.md\\\"\\n     },\\n     \\\"Media Playback Nodes\\\":{\\n        \\\"Audio\\\":\\\"/docs/references/scenegraph/media-playback-nodes/audio.md\\\",\\n        \\\"SoundEffect\\\":\\\"/docs/references/scenegraph/media-playback-nodes/soundeffect.md\\\",\\n        \\\"Video\\\":\\\"/docs/references/scenegraph/media-playback-nodes/video.md\\\"\\n     }\\n  },\\n\\n      \\\"BrightScript\\\":{\\n\\n        \\\"Language\\\":{\\n             \\\"Language reference\\\":\\\"/docs/references/brightscript/language/brightscript-language-reference.md\\\",\\n             \\\"Statement summary\\\":\\\"/docs/references/brightscript/language/statement-summary.md\\\",\\n             \\\"Expressions, variables, and types\\\":\\\"/docs/references/brightscript/language/expressions-variables-types.md\\\",\\n             \\\"Component architecture\\\":\\\"/docs/references/brightscript/language/component-architecture.md\\\",\\n             \\\"Program statements\\\":\\\"/docs/references/brightscript/language/program-statements.md\\\",\\n             \\\"Runtime functions\\\":\\\"/docs/references/brightscript/language/runtime-functions.md\\\",\\n             \\\"Error handling facilities\\\":\\\"/docs/references/brightscript/language/error-handling.md\\\",\\n             \\\"Global utility functions\\\":\\\"/docs/references/brightscript/language/global-utility-functions.md\\\",\\n             \\\"Global string functions\\\":\\\"/docs/references/brightscript/language/global-string-functions.md\\\",\\n             \\\"Global math functions\\\":\\\"/docs/references/brightscript/language/global-math-functions.md\\\",\\n             \\\"Reserved words\\\":\\\"/docs/references/brightscript/language/reserved-words.md\\\",\\n             \\\"Conditional compilation\\\":\\\"/docs/references/brightscript/language/conditional-compilation.md\\\"\\n          },\\n\\n         \\\"Components\\\":{\\n            \\\"roAppInfo\\\":\\\"/docs/references/brightscript/components/roappinfo.md\\\",\\n            \\\"roAppManager\\\":\\\"/docs/references/brightscript/components/roappmanager.md\\\",\\n            \\\"roArray\\\":\\\"/docs/references/brightscript/components/roarray.md\\\",\\n            \\\"roAssociativeArray\\\":\\\"/docs/references/brightscript/components/roassociativearray.md\\\",\\n            \\\"roAudioGuide\\\":\\\"/docs/references/brightscript/components/roaudioguide.md\\\",\\n            \\\"roAudioMetadata\\\":\\\"/docs/references/brightscript/components/roaudiometadata.md\\\",\\n            \\\"roAudioPlayer\\\":\\\"/docs/references/brightscript/components/roaudioplayer.md\\\",\\n            \\\"roAudioResource\\\":\\\"/docs/references/brightscript/components/roaudioresource.md\\\",\\n            \\\"roBitmap\\\":\\\"/docs/references/brightscript/components/robitmap.md\\\",\\n            \\\"roBoolean\\\":\\\"/docs/references/brightscript/components/roboolean.md\\\",\\n            \\\"roByteArray\\\":\\\"/docs/references/brightscript/components/robytearray.md\\\",\\n            \\\"roCaptionRenderer\\\":\\\"/docs/references/brightscript/components/rocaptionrenderer.md\\\",\\n            \\\"roChannelStore\\\":\\\"/docs/references/brightscript/components/rochannelstore.md\\\",\\n            \\\"roCodeRegistrationScreen\\\":\\\"/docs/references/brightscript/components/rocoderegistrationscreen.md\\\",\\n            \\\"roCompositor\\\":\\\"/docs/references/brightscript/components/rocompositor.md\\\",\\n            \\\"roDataGramSocket\\\":\\\"/docs/references/brightscript/components/rodatagramsocket.md\\\",\\n            \\\"roDateTime\\\":\\\"/docs/references/brightscript/components/rodatetime.md\\\",\\n            \\\"roDeviceInfo\\\":\\\"/docs/references/brightscript/components/rodeviceinfo.md\\\",\\n            \\\"roDouble\\\":\\\"/docs/references/brightscript/components/rodouble.md\\\",\\n            \\\"roDeviceCrypto\\\":\\\"/docs/references/brightscript/components/rodevicecrypto.md\\\",\\n            \\\"roEVPCipher\\\":\\\"/docs/references/brightscript/components/roevpcipher.md\\\",\\n            \\\"roEVPDigest\\\":\\\"/docs/references/brightscript/components/roevpdigest.md\\\",\\n            \\\"roFileSystem\\\":\\\"/docs/references/brightscript/components/rofilesystem.md\\\",\\n            \\\"roFloat\\\":\\\"/docs/references/brightscript/components/rofloat.md\\\",\\n            \\\"roFont\\\":\\\"/docs/references/brightscript/components/rofont.md\\\",\\n            \\\"roFontMetrics\\\":\\\"/docs/references/brightscript/components/rofontmetrics.md\\\",\\n            \\\"roFontRegistry\\\":\\\"/docs/references/brightscript/components/rofontregistry.md\\\",\\n            \\\"roFunction\\\":\\\"/docs/references/brightscript/components/rofunction.md\\\",\\n            \\\"roGridScreen\\\":\\\"/docs/references/brightscript/components/rogridscreen.md\\\",\\n            \\\"roHdmiStatus\\\":\\\"/docs/references/brightscript/components/rohdmistatus.md\\\",\\n            \\\"roHMAC\\\":\\\"/docs/references/brightscript/components/rohmac.md\\\",\\n            \\\"roHttpAgent\\\":\\\"/docs/references/brightscript/components/rohttpagent.md\\\",\\n            \\\"roImageCanvas\\\":\\\"/docs/references/brightscript/components/roimagecanvas.md\\\",\\n            \\\"roImageMetaData\\\":\\\"/docs/references/brightscript/components/roimagemetadata.md\\\",\\n            \\\"roInput\\\":\\\"/docs/references/brightscript/components/roinput.md\\\",\\n            \\\"roInt\\\":\\\"/docs/references/brightscript/components/roint.md\\\",\\n            \\\"roInvalid\\\":\\\"/docs/references/brightscript/components/roinvalid.md\\\",\\n            \\\"roKeyboardScreen\\\":\\\"/docs/references/brightscript/components/rokeyboardscreen.md\\\",\\n            \\\"roList\\\":\\\"/docs/references/brightscript/components/rolist.md\\\",\\n            \\\"roListScreen\\\":\\\"/docs/references/brightscript/components/rolistscreen.md\\\",\\n            \\\"roLocalization\\\":\\\"/docs/references/brightscript/components/rolocalization.md\\\",\\n            \\\"roLongInteger\\\":\\\"/docs/references/brightscript/components/rolonginteger.md\\\",\\n            \\\"roMessageDialog\\\":\\\"/docs/references/brightscript/components/romessagedialog.md\\\",\\n            \\\"roMessagePort\\\":\\\"/docs/references/brightscript/components/romessageport.md\\\",\\n            \\\"roMicrophone\\\":\\\"/docs/references/brightscript/components/romicrophone.md\\\",\\n            \\\"roOneLineDialog\\\":\\\"/docs/references/brightscript/components/roonelinedialog.md\\\",\\n            \\\"roParagraphScreen\\\":\\\"/docs/references/brightscript/components/roparagraphscreen.md\\\",\\n            \\\"roPath\\\":\\\"/docs/references/brightscript/components/ropath.md\\\",\\n            \\\"roPinEntryDialog\\\":\\\"/docs/references/brightscript/components/ropinentrydialog.md\\\",\\n            \\\"roPosterScreen\\\":\\\"/docs/references/brightscript/components/roposterscreen.md\\\",\\n            \\\"roProgramGuide\\\":\\\"/docs/references/brightscript/components/roprogramguide.md\\\",\\n            \\\"roRegex\\\":\\\"/docs/references/brightscript/components/roregex.md\\\",\\n            \\\"roRegion\\\":\\\"/docs/references/brightscript/components/roregion.md\\\",\\n            \\\"roRegistry\\\":\\\"/docs/references/brightscript/components/roregistry.md\\\",\\n            \\\"roRegistrySection\\\":\\\"/docs/references/brightscript/components/roregistrysection.md\\\",\\n            \\\"roRSA\\\":\\\"/docs/references/brightscript/components/rorsa.md\\\",\\n            \\\"roScreen\\\":\\\"/docs/references/brightscript/components/roscreen.md\\\",\\n            \\\"roSearchHistory\\\":\\\"/docs/references/brightscript/components/rosearchhistory.md\\\",\\n            \\\"roSearchScreen\\\":\\\"/docs/references/brightscript/components/rosearchscreen.md\\\",\\n            \\\"roSGNode\\\":\\\"/docs/references/brightscript/components/rosgnode.md\\\",\\n            \\\"roSGScreen\\\":\\\"/docs/references/brightscript/components/rosgscreen.md\\\",\\n            \\\"roSlideShow\\\":\\\"/docs/references/brightscript/components/roslideshow.md\\\",\\n            \\\"roSocketAddress\\\":\\\"/docs/references/brightscript/components/rosocketaddress.md\\\",\\n            \\\"roSpringboardScreen\\\":\\\"/docs/references/brightscript/components/rospringboardscreen.md\\\",\\n            \\\"roSprite\\\":\\\"/docs/references/brightscript/components/rosprite.md\\\",\\n            \\\"roStreamSocket\\\":\\\"/docs/references/brightscript/components/rostreamsocket.md\\\",\\n            \\\"roString\\\":\\\"/docs/references/brightscript/components/rostring.md\\\",\\n            \\\"roSystemlog\\\":\\\"/docs/references/brightscript/components/rosystemlog.md\\\",\\n            \\\"roTextScreen\\\":\\\"/docs/references/brightscript/components/rotextscreen.md\\\",\\n            \\\"roTextToSpeech\\\":\\\"/docs/references/brightscript/components/rotexttospeech.md\\\",\\n            \\\"roTextureManager\\\":\\\"/docs/references/brightscript/components/rotexturemanager.md\\\",\\n            \\\"roTextureRequest\\\":\\\"/docs/references/brightscript/components/rotexturerequest.md\\\",\\n            \\\"roTimespan\\\":\\\"/docs/references/brightscript/components/rotimespan.md\\\",\\n            \\\"roUrlTransfer\\\":\\\"/docs/references/brightscript/components/rourltransfer.md\\\",\\n            \\\"roVideoPlayer\\\":\\\"/docs/references/brightscript/components/rovideoplayer.md\\\",\\n            \\\"roVideoScreen\\\":\\\"/docs/references/brightscript/components/rovideoscreen.md\\\",\\n            \\\"roXMLElement\\\":\\\"/docs/references/brightscript/components/roxmlelement.md\\\",\\n            \\\"roXMLList\\\":\\\"/docs/references/brightscript/components/roxmllist.md\\\"\\n         },\\n\\n         \\\"Interfaces\\\":{\\n\\n            \\\"ifAppInfo\\\":\\\"/docs/references/brightscript/interfaces/ifappinfo.md\\\",\\n            \\\"ifAppManager\\\":\\\"/docs/references/brightscript/interfaces/ifappmanager.md\\\",\\n            \\\"ifArray\\\":\\\"/docs/references/brightscript/interfaces/ifarray.md\\\",\\n            \\\"ifArrayGet\\\":\\\"/docs/references/brightscript/interfaces/ifarrayget.md\\\",\\n            \\\"ifArrayJoin\\\":\\\"/docs/references/brightscript/interfaces/ifarrayjoin.md\\\",\\n            \\\"ifArraySet\\\":\\\"/docs/references/brightscript/interfaces/ifarrayset.md\\\",\\n            \\\"ifArraySort\\\":\\\"/docs/references/brightscript/interfaces/ifarraysort.md\\\",\\n            \\\"ifAssociativeArray\\\":\\\"/docs/references/brightscript/interfaces/ifassociativearray.md\\\",\\n            \\\"ifAudioGuide\\\":\\\"/docs/references/brightscript/interfaces/ifaudioguide.md\\\",\\n            \\\"ifAudioMetaData\\\":\\\"/docs/references/brightscript/interfaces/ifaudiometadata.md\\\",\\n            \\\"ifAudioPlayer\\\":\\\"/docs/references/brightscript/interfaces/ifaudioplayer.md\\\",\\n            \\\"ifAudioResource\\\":\\\"/docs/references/brightscript/interfaces/ifaudioresource.md\\\",\\n            \\\"ifBoolean\\\":\\\"/docs/references/brightscript/interfaces/ifboolean.md\\\",\\n            \\\"ifByteArray\\\":\\\"/docs/references/brightscript/interfaces/ifbytearray.md\\\",\\n            \\\"ifCaptionRenderer\\\":\\\"/docs/references/brightscript/interfaces/ifcaptionrenderer.md\\\",\\n            \\\"ifChannelStore\\\":\\\"/docs/references/brightscript/interfaces/ifchannelstore.md\\\",\\n            \\\"ifCodeRegistrationScreen\\\":\\\"/docs/references/brightscript/interfaces/ifcoderegistrationscreen.md\\\",\\n            \\\"ifCompositor\\\":\\\"/docs/references/brightscript/interfaces/ifcompositor.md\\\",\\n            \\\"ifDateTime\\\":\\\"/docs/references/brightscript/interfaces/ifdatetime.md\\\",\\n            \\\"ifDeviceInfo\\\":\\\"/docs/references/brightscript/interfaces/ifdeviceinfo.md\\\",\\n            \\\"ifDeviceCrypto\\\":\\\"/docs/references/brightscript/interfaces/ifdevicecrypto.md\\\",\\n            \\\"ifDouble\\\":\\\"/docs/references/brightscript/interfaces/ifdouble.md\\\",\\n            \\\"ifDraw2D\\\":\\\"/docs/references/brightscript/interfaces/ifdraw2d.md\\\",\\n            \\\"ifEnum\\\":\\\"/docs/references/brightscript/interfaces/ifenum.md\\\",\\n            \\\"ifEVPCipher\\\":\\\"/docs/references/brightscript/interfaces/ifevpcipher.md\\\",\\n            \\\"ifEVPDigest\\\":\\\"/docs/references/brightscript/interfaces/ifevpdigest.md\\\",\\n            \\\"ifFileSystem\\\":\\\"/docs/references/brightscript/interfaces/iffilesystem.md\\\",\\n            \\\"ifFloat\\\":\\\"/docs/references/brightscript/interfaces/iffloat.md\\\",\\n            \\\"ifFont\\\":\\\"/docs/references/brightscript/interfaces/iffont.md\\\",\\n            \\\"ifFontMetrics\\\":\\\"/docs/references/brightscript/interfaces/iffontmetrics.md\\\",\\n            \\\"ifFontRegistry\\\":\\\"/docs/references/brightscript/interfaces/iffontregistry.md\\\",\\n            \\\"ifFunction\\\":\\\"/docs/references/brightscript/interfaces/iffunction.md\\\",\\n            \\\"ifGetMessagePort\\\":\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\",\\n            \\\"ifGridScreen\\\":\\\"/docs/references/brightscript/interfaces/ifgridscreen.md\\\",\\n            \\\"ifHdmiStatus\\\":\\\"/docs/references/brightscript/interfaces/ifhdmistatus.md\\\",\\n            \\\"ifHMAC\\\":\\\"/docs/references/brightscript/interfaces/ifhmac.md\\\",\\n            \\\"ifHttpAgent\\\":\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\",\\n            \\\"ifImageCanvas\\\":\\\"/docs/references/brightscript/interfaces/ifimagecanvas.md\\\",\\n            \\\"ifImageMetaData\\\":\\\"/docs/references/brightscript/interfaces/ifimagemetadata.md\\\",\\n            \\\"ifInput\\\":\\\"/docs/references/brightscript/interfaces/ifinput.md\\\",\\n            \\\"ifInt\\\":\\\"/docs/references/brightscript/interfaces/ifint.md\\\",\\n            \\\"ifIntOps\\\":\\\"/docs/references/brightscript/interfaces/ifintops.md\\\",\\n            \\\"ifKeyboardScreen\\\":\\\"/docs/references/brightscript/interfaces/ifkeyboardscreen.md\\\",\\n            \\\"ifList\\\":\\\"/docs/references/brightscript/interfaces/iflist.md\\\",\\n            \\\"ifListScreen\\\":\\\"/docs/references/brightscript/interfaces/iflistscreen.md\\\",\\n            \\\"ifListToArray\\\":\\\"/docs/references/brightscript/interfaces/iflisttoarray.md\\\",\\n            \\\"ifLocalization\\\":\\\"/docs/references/brightscript/interfaces/iflocalization.md\\\",\\n            \\\"ifLongInt\\\":\\\"/docs/references/brightscript/interfaces/iflongint.md\\\",\\n            \\\"ifMessageDialog\\\":\\\"/docs/references/brightscript/interfaces/ifmessagedialog.md\\\",\\n            \\\"ifMessagePort\\\":\\\"/docs/references/brightscript/interfaces/ifmessageport.md\\\",\\n            \\\"ifMicrophone\\\":\\\"/docs/references/brightscript/interfaces/ifmicrophone.md\\\",\\n            \\\"ifOneLineDialog\\\":\\\"/docs/references/brightscript/interfaces/ifonelinedialog.md\\\",\\n            \\\"ifParagraphScreen\\\":\\\"/docs/references/brightscript/interfaces/ifparagraphscreen.md\\\",\\n            \\\"ifPath\\\":\\\"/docs/references/brightscript/interfaces/ifpath.md\\\",\\n            \\\"ifPinEntryDialog\\\":\\\"/docs/references/brightscript/interfaces/ifpinentrydialog.md\\\",\\n            \\\"ifPosterScreen\\\":\\\"/docs/references/brightscript/interfaces/ifposterscreen.md\\\",\\n            \\\"ifProgramGuide\\\":\\\"/docs/references/brightscript/interfaces/ifprogramguide.md\\\",\\n            \\\"ifRegex\\\":\\\"/docs/references/brightscript/interfaces/ifregex.md\\\",\\n            \\\"ifRegion\\\":\\\"/docs/references/brightscript/interfaces/ifregion.md\\\",\\n            \\\"ifRegistry\\\":\\\"/docs/references/brightscript/interfaces/ifregistry.md\\\",\\n            \\\"ifRegistrySection\\\":\\\"/docs/references/brightscript/interfaces/ifregistrysection.md\\\",\\n            \\\"ifSGScreen\\\":\\\"/docs/references/brightscript/interfaces/ifsgscreen.md\\\",\\n            \\\"ifRSA\\\":\\\"/docs/references/brightscript/interfaces/ifrsa.md\\\",\\n            \\\"ifScreen\\\":\\\"/docs/references/brightscript/interfaces/ifscreen.md\\\",\\n            \\\"ifSearchhistory\\\":\\\"/docs/references/brightscript/interfaces/ifsearchhistory.md\\\",\\n            \\\"ifSearchScreen\\\":\\\"/docs/references/brightscript/interfaces/ifsearchscreen.md\\\",\\n            \\\"ifSetMessagePort\\\":\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\",\\n            \\\"ifSGNodeBoundingRect\\\":\\\"/docs/references/brightscript/interfaces/ifsgnodeboundingrect.md\\\",\\n            \\\"ifSGNodeChildren\\\":\\\"/docs/references/brightscript/interfaces/ifsgnodechildren.md\\\",\\n            \\\"ifSGNodeDict\\\":\\\"/docs/references/brightscript/interfaces/ifsgnodedict.md\\\",\\n            \\\"ifSGNodeField\\\":\\\"/docs/references/brightscript/interfaces/ifsgnodefield.md\\\",\\n            \\\"ifSGNodeFocus\\\":\\\"/docs/references/brightscript/interfaces/ifsgnodefocus.md\\\",\\n            \\\"ifSGNodeHttpAgentAccess\\\":\\\"/docs/references/brightscript/interfaces/ifsgnodehttpagentaccess.md\\\",\\n            \\\"ifSlideshow\\\":\\\"/docs/references/brightscript/interfaces/ifslideshow.md\\\",\\n            \\\"ifSocket\\\":\\\"/docs/references/brightscript/interfaces/ifsocket.md\\\",\\n            \\\"ifSocketAddress\\\":\\\"/docs/references/brightscript/interfaces/ifsocketaddress.md\\\",\\n            \\\"ifSocketAsync\\\":\\\"/docs/references/brightscript/interfaces/ifsocketasync.md\\\",\\n            \\\"ifSocketCastOption\\\":\\\"/docs/references/brightscript/interfaces/ifsocketcastoption.md\\\",\\n            \\\"ifSocketConnection\\\":\\\"/docs/references/brightscript/interfaces/ifsocketconnection.md\\\",\\n            \\\"ifSocketConnectionoption\\\":\\\"/docs/references/brightscript/interfaces/ifsocketconnectionoption.md\\\",\\n            \\\"ifSocketConnectionstatus\\\":\\\"/docs/references/brightscript/interfaces/ifsocketconnectionstatus.md\\\",\\n            \\\"ifSocketOption\\\":\\\"/docs/references/brightscript/interfaces/ifsocketoption.md\\\",\\n            \\\"ifSocketStatus\\\":\\\"/docs/references/brightscript/interfaces/ifsocketstatus.md\\\",\\n            \\\"ifSourceIdentity\\\":\\\"/docs/references/brightscript/interfaces/ifsourceidentity.md\\\",\\n            \\\"ifSpringboardScreen\\\":\\\"/docs/references/brightscript/interfaces/ifspringboardscreen.md\\\",\\n            \\\"ifSprite\\\":\\\"/docs/references/brightscript/interfaces/ifsprite.md\\\",\\n            \\\"ifString\\\":\\\"/docs/references/brightscript/interfaces/ifstring.md\\\",\\n            \\\"ifStringOps\\\":\\\"/docs/references/brightscript/interfaces/ifstringops.md\\\",\\n            \\\"ifSystemLog\\\":\\\"/docs/references/brightscript/interfaces/ifsystemlog.md\\\",\\n            \\\"ifTextScreen\\\":\\\"/docs/references/brightscript/interfaces/iftextscreen.md\\\",\\n            \\\"ifTextToSpeech\\\":\\\"/docs/references/brightscript/interfaces/iftexttospeech.md\\\",\\n            \\\"ifTextureManager\\\":\\\"/docs/references/brightscript/interfaces/iftexturemanager.md\\\",\\n            \\\"ifTextureRequest\\\":\\\"/docs/references/brightscript/interfaces/iftexturerequest.md\\\",\\n            \\\"ifTimeSpan\\\":\\\"/docs/references/brightscript/interfaces/iftimespan.md\\\",\\n            \\\"ifToStr\\\":\\\"/docs/references/brightscript/interfaces/iftostr.md\\\",\\n            \\\"ifUrlTransfer\\\":\\\"/docs/references/brightscript/interfaces/ifurltransfer.md\\\",\\n            \\\"ifVideoPlayer\\\":\\\"/docs/references/brightscript/interfaces/ifvideoplayer.md\\\",\\n            \\\"ifVideoScreen\\\":\\\"/docs/references/brightscript/interfaces/ifvideoscreen.md\\\",\\n            \\\"ifXMLElement\\\":\\\"/docs/references/brightscript/interfaces/ifxmlelement.md\\\",\\n            \\\"ifXMLList\\\":\\\"/docs/references/brightscript/interfaces/ifxmllist.md\\\"\\n         },\\n\\n         \\\"Events\\\":{\\n\\n            \\\"roAudioPlayerEvent\\\":\\\"/docs/references/brightscript/events/roaudioplayerevent.md\\\",\\n            \\\"roCaptionRendererEvent\\\":\\\"/docs/references/brightscript/events/rocaptionrendererevent.md\\\",\\n            \\\"roCECStatusEvent\\\":\\\"/docs/references/brightscript/events/rocecstatusevent.md\\\",\\n            \\\"roChannelStoreEvent\\\":\\\"/docs/references/brightscript/events/rochannelstoreevent.md\\\",\\n            \\\"roCodeRegistrationScreenEvent\\\":\\\"/docs/references/brightscript/events/rocoderegistrationscreenevent.md\\\",\\n            \\\"roDeviceInfoEvent\\\":\\\"/docs/references/brightscript/events/rodeviceinfoevent.md\\\",\\n            \\\"roFileSystemEvent\\\":\\\"/docs/references/brightscript/events/rofilesystemevent.md\\\",\\n            \\\"roGridScreenEvent\\\":\\\"/docs/references/brightscript/events/rogridscreenevent.md\\\",\\n            \\\"roHdmiHotPlugEvent\\\":\\\"/docs/references/brightscript/events/rohdmihotplugevent.md\\\",\\n            \\\"roHdmiStatusEvent\\\":\\\"/docs/references/brightscript/events/rohdmistatusevent.md\\\",\\n            \\\"roImageCanvasEvent\\\":\\\"/docs/references/brightscript/events/roimagecanvasevent.md\\\",\\n            \\\"roInputEvent\\\":\\\"/docs/references/brightscript/events/roinputevent.md\\\",\\n            \\\"roKeyboardScreenEvent\\\":\\\"/docs/references/brightscript/events/rokeyboardscreenevent.md\\\",\\n            \\\"roListScreenEvent\\\":\\\"/docs/references/brightscript/events/rolistscreenevent.md\\\",\\n            \\\"roMessageDialogEvent\\\":\\\"/docs/references/brightscript/events/romessagedialogevent.md\\\",\\n            \\\"roMicrophoneEvent\\\":\\\"/docs/references/brightscript/events/romicrophoneevent.md\\\",\\n            \\\"roOneLineDialogEvent\\\":\\\"/docs/references/brightscript/events/roonelinedialogevent.md\\\",\\n            \\\"roParagraphScreenEvent\\\":\\\"/docs/references/brightscript/events/roparagraphscreenevent.md\\\",\\n            \\\"roPinEntryDialogEvent\\\":\\\"/docs/references/brightscript/events/ropinentrydialogevent.md\\\",\\n            \\\"roPosterScreenEvent\\\":\\\"/docs/references/brightscript/events/roposterscreenevent.md\\\",\\n            \\\"roSearchScreenEvent\\\":\\\"/docs/references/brightscript/events/rosearchscreenevent.md\\\",\\n            \\\"roSGNodeEvent\\\":\\\"/docs/references/brightscript/events/rosgnodeevent.md\\\",\\n            \\\"roSGScreenEvent\\\":\\\"/docs/references/brightscript/events/rosgscreenevent.md\\\",\\n            \\\"roSlideShowEvent\\\":\\\"/docs/references/brightscript/events/roslideshowevent.md\\\",\\n            \\\"roSocketEvent\\\":\\\"/docs/references/brightscript/events/rosocketevent.md\\\",\\n            \\\"roSpringboardScreenEvent\\\":\\\"/docs/references/brightscript/events/rospringboardscreenevent.md\\\",\\n            \\\"roSystemLogEvent\\\":\\\"/docs/references/brightscript/events/rosystemlogevent.md\\\",\\n            \\\"roTextScreenEvent\\\":\\\"/docs/references/brightscript/events/rotextscreenevent.md\\\",\\n            \\\"roTextToSpeechEvent\\\":\\\"/docs/references/brightscript/events/rotexttospeechevent.md\\\",\\n            \\\"roTextureRequestEvent\\\":\\\"/docs/references/brightscript/events/rotexturerequestevent.md\\\",\\n            \\\"roUniversalControlEvent\\\":\\\"/docs/references/brightscript/events/rouniversalcontrolevent.md\\\",\\n            \\\"roUrlEvent\\\":\\\"/docs/references/brightscript/events/rourlevent.md\\\",\\n            \\\"roVideoPlayerEvent\\\":\\\"/docs/references/brightscript/events/rovideoplayerevent.md\\\",\\n            \\\"roVideoScreenEvent\\\":\\\"/docs/references/brightscript/events/rovideoscreenevent.md\\\"\\n         }\\n      },\\n\\n      \\\"Deprecated APIs\\\":\\\"/docs/references/deprecated-apis.md\\\"\\n}\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roappinfo.md":"{\n  \"content\": \"<h1 id=\\\"roappinfo\\\">roAppInfo</h1>\\n<p>roAppInfo retrieves the developer ID, which can be useful during development. It also retrieves manifest values, such as the title and version number, avoiding the need to parse the manifest file from BrightScript.\\nThis object is created with no parameters.</p>\\n<h4 id=\\\"example\\\">Example</h4>\\n<p><strong>Implementation</strong></p>\\n<pre><code>brush: vb; gutter: false; theme: Confluence\\nappInfo = CreateObject(\\\"roAppInfo\\\")\\n\\nprint \\\"     ID: \\\" ; appInfo.GetID()\\nprint \\\"  IsDev: \\\" ; appInfo.IsDev()\\nprint \\\"  DevID: \\\" ; appInfo.GetDevID()\\nprint \\\"  Title: \\\" ; appInfo.GetTitle()\\nprint \\\"Version: \\\" ; appInfo.GetVersion()\\nprint \\\"MajVers: \\\" ; appInfo.GetValue(\\\"major_version\\\")\\n</code></pre>\\n<p><strong>Output</strong></p>\\n<pre><code>brush: plain; gutter: false; theme: Confluence\\n'      ID: 41089_bd3a\\n'   IsDev: false\\n'   DevID: 990df3584920876b7e74fe7b29e1f505f148373b\\n'   Title: BrightScript Test\\n' Version: 1.0.0\\n' MajVers: 1 \\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifappinfo.md\\\" title=\\\"ifAppInfo\\\">ifAppInfo</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roappmanager.md":"{\n  \"content\": \"<h1 id=\\\"roappmanager\\\">roAppManager</h1>\\n<p>The Application Manager APIs set application level attributes, which mostly affect the look-and-feel of the application. The use of screen styles gives each application a consistent look-and-feel, but it's often desirable to customize attributes such as colors, fonts, and logos for each application. Setting artwork and colors allows the developer to specify a theme for their application. If these values are not set, the application will use default values.</p>\\n<p>The table below describes each attribute and its values, the screen types to which it applies, and the Roku OS version in which the attribute was first supported. Unless otherwise indicated, an attribute is supported in all Roku OS versions after the one in which it was first supported.</p>\\n<p>To save space, the screen types in the table are specified by a two letter code:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Code</th>\\n<th>Screen Type</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Co</td>\\n<td>roCodeRegistrationScreen</td>\\n</tr>\\n<tr>\\n<td>Di</td>\\n<td>roMessageDialog, roOneLineDialog, roPinEntryDialog</td>\\n</tr>\\n<tr>\\n<td>Gr</td>\\n<td>roGridScreen</td>\\n</tr>\\n<tr>\\n<td>Ke</td>\\n<td>roKeyboardScreen</td>\\n</tr>\\n<tr>\\n<td>Li</td>\\n<td>roListScreen</td>\\n</tr>\\n<tr>\\n<td>Pa</td>\\n<td>roParagraphScreen</td>\\n</tr>\\n<tr>\\n<td>Po</td>\\n<td>roPosterScreen</td>\\n</tr>\\n<tr>\\n<td>Se</td>\\n<td>roSearchScreen</td>\\n</tr>\\n<tr>\\n<td>Sp</td>\\n<td>roSpringboardScreen</td>\\n</tr>\\n<tr>\\n<td>Te</td>\\n<td>roTextScreen</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>All attribute values are strings. Numeric values are specified as decimal strings.</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Attribute</th>\\n<th>Screen Types</th>\\n<th>Values</th>\\n<th>Example</th>\\n<th>Version</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>BackgroundColor</td>\\n<td>Gr Li Pa Po Se Sp Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#E0DFDF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>BreadcrumbDelimiter</td>\\n<td>Gr Li Pa Po Se Sp Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>BreadcrumbTextLeft</td>\\n<td>Gr Li Pa Po Se Sp Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>BreadcrumbTextRight</td>\\n<td>Gr Li Pa Po Se Sp Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>ButtonHighlightColor</td>\\n<td>Di Se Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>ButtonMenuHighlightText</td>\\n<td>Di Se Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#0033FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>ButtonMenuNormalOverlayText</td>\\n<td>Di Se Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#B0B0B0</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>ButtonMenuNormalText</td>\\n<td>Di Se Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#686868</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>ButtonNormalColor</td>\\n<td>Di Se Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>CounterSeparator</td>\\n<td>Gr Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#00FF00</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>CounterTextLeft</td>\\n<td>Gr Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF0000</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>CounterTextRight</td>\\n<td>Gr Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#0000FF</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>DialogBodyText</td>\\n<td>Di</td>\\n<td>HTML HEX Color Value. Must be a grayscale value</td>\\n<td>#808080</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>DialogTitleText</td>\\n<td>Di</td>\\n<td>HTML HEX Color Value. Must be a grayscale value</td>\\n<td>#363636</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>EpisodeSynopsisText</td>\\n<td>Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerActiveColor</td>\\n<td>Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerActiveHD</td>\\n<td>Po</td>\\n<td>URL to set HD Filter Banner Active/Focus Highlighter</td>\\n<td>pkg:/images/Filter_ActiveHint_HD.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerActiveSD</td>\\n<td>Po</td>\\n<td>URL to set SD Filter Banner Active/Focus Highlighter</td>\\n<td>pkg:/images/Filter_ActiveHint_SD43.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerInactiveColor</td>\\n<td>Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerInactiveHD</td>\\n<td>Po</td>\\n<td>URL to set HD Filter Banner Inactive Highlighter</td>\\n<td>pkg:/images/Filter_InactiveHint_HD.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerInactiveSD</td>\\n<td>Po</td>\\n<td>URL to set SD Filter Banner Inactive Highlighter</td>\\n<td>pkg:/images/Filter_ActiveHint_SD43.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerSideColor</td>\\n<td>Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerSliceHD</td>\\n<td>Po</td>\\n<td>URL to set HD Filter Banner Background Image</td>\\n<td>pkg:/images/Filter_ActiveHint_HD.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>FilterBannerSliceSD</td>\\n<td>Po</td>\\n<td>URL to set SD Filter Banner Background Image</td>\\n<td>pkg:/images/Filter_ActiveHint_SD43.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>GridScreenBackgroundColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value Must be a grayscale value</td>\\n<td>#363636</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenBorderOffsetHD</td>\\n<td>Gr</td>\\n<td>String representing point \\\"(x, y)\\\" that is the offset from the upper left corner of the focused HD image. Set to the negative width &#x26; height of border</td>\\n<td>(-25,-25)</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenBorderOffsetSD</td>\\n<td>Gr</td>\\n<td>String representing point \\\"(x, y)\\\" that is the offset from the upper left corner of the focused SD image. Set to the negative width &#x26; height of border</td>\\n<td>(-20,-20)</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionDateColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF005B</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionImageHD</td>\\n<td>Gr</td>\\n<td>URL to set HD Description callout background image on Grid</td>\\n<td>pkg:/images/Description_Background_HD.ng</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionImageSD</td>\\n<td>Gr</td>\\n<td>URL to set SD Description callout background image on Grid</td>\\n<td>pkg:/images/Description_Background_SD43.ng</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionOffsetHD</td>\\n<td>Gr</td>\\n<td>String representing point \\\"(x, y)\\\" that is the offset from the upper left corner of the focused HD image. Negative values have the description above and to the left of the focused image</td>\\n<td>(190,255)</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionOffsetSD</td>\\n<td>Gr</td>\\n<td>String representing point \\\"(x, y)\\\" that is the offset from the upper left corner of the focused SD image. Negative values have the description above and to the left of the focused image</td>\\n<td>(125,170)</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionRuntimeColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value</td>\\n<td>#5B005B</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionSynopsisColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value</td>\\n<td>#606000</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenDescriptionTitleColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value</td>\\n<td>#00FFFF</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenFocusBorderHD</td>\\n<td>Gr</td>\\n<td>URL to set HD Focus image on Active Grid Poster</td>\\n<td>pkg:/images/Border_16x9_HD.png</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenFocusBorderSD</td>\\n<td>Gr</td>\\n<td>URL to set SD Focus image on Active Grid Poster</td>\\n<td>pkg:/images/Border_16x9_SD43.png</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenListNameColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value. Must be a grayscale value</td>\\n<td>#FFFFFF</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenLogoHD</td>\\n<td>Gr</td>\\n<td>Logo formatted for display in the overhang</td>\\n<td>pkg:/images/gridlogoHD.png</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenLogoOffsetHD_X</td>\\n<td>Gr</td>\\n<td>Offset in pixels from the top-left origin of the display. Range 0 to 1280</td>\\n<td>592</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenLogoOffsetHD_Y</td>\\n<td>Gr</td>\\n<td>Offset in pixels from the top-left origin of the display. Range 0 to 720</td>\\n<td>31</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenLogoOffsetSD_X</td>\\n<td>Gr</td>\\n<td>Offset in pixels from the top-left origin of the display. Range 0 to 720</td>\\n<td>324</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenLogoOffsetSD_Y</td>\\n<td>Gr</td>\\n<td>Offset in pixels from the top-left origin of the display. Range 0 to 480</td>\\n<td>21</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenLogoSD</td>\\n<td>Gr</td>\\n<td>Logo formatted for display in the overhang</td>\\n<td>pkg:/images/gridlogoSD.png</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenMessageColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value. Must be a grayscale value</td>\\n<td>#808080</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenOverhangHeightHD</td>\\n<td>Gr</td>\\n<td>The HD overhang height. Default: \\\"69\\\"</td>\\n<td>75</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenOverhangHeightSD</td>\\n<td>Gr</td>\\n<td>The SD overhang height. Default: \\\"49\\\"</td>\\n<td>55</td>\\n<td>2.8</td>\\n</tr>\\n<tr>\\n<td>GridScreenOverhangSliceHD</td>\\n<td>Gr</td>\\n<td>URI for the overhang slice (thin piece of top of screen border)</td>\\n<td>pkg:/images/gridoverhangHD.png</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenOverhangSliceSD</td>\\n<td>Gr</td>\\n<td>URI for the overhang slice (thin piece of top of screen border)</td>\\n<td>pkg:/images/gridoverhangSD.png</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>GridScreenRetrievingColor</td>\\n<td>Gr</td>\\n<td>HTML HEX Color Value. Must be a grayscale value</td>\\n<td>#CCCCCC</td>\\n<td>2.7</td>\\n</tr>\\n<tr>\\n<td>ListItemHighlightHD</td>\\n<td>Gr Li Po</td>\\n<td>URL to set HD highlight image</td>\\n<td>pkg:/images/listitem_highlight_hd.png</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>ListItemHighlightSD</td>\\n<td>Gr Li Po</td>\\n<td>URL to set SD highlight image</td>\\n<td>pkg:/images/listitem_highlight_sd.png</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>ListItemHighlightText</td>\\n<td>Gr Li Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#CCCC00</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>ListItemText</td>\\n<td>Gr Li Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#CCCC00</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>ListScreenDescriptionText</td>\\n<td>Li</td>\\n<td>HTML HEX Color Value</td>\\n<td>#CCCC00</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>ListScreenTitleColor</td>\\n<td>Li</td>\\n<td>HTML HEX Color Value</td>\\n<td>#CC0000</td>\\n<td>3.1</td>\\n</tr>\\n<tr>\\n<td>OverhangPrimaryLogoHD</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Small application logo formatted for display in overhang top left</td>\\n<td>pkg:/images/co_logo_sd.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangPrimaryLogoOffsetHD_X</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films.Range 0 to 1280</td>\\n<td>25</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangPrimaryLogoOffsetHD_Y</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films.Range 0 to 720</td>\\n<td>50</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangPrimaryLogoOffsetSD_X</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films.Range 0 to 720</td>\\n<td>25</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangPrimaryLogoOffsetSD_Y</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films.Range 0 to 480</td>\\n<td>50</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangPrimaryLogoSD</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Small application logo formatted for display in overhang top left</td>\\n<td>pkg:/images/co_logo_sd.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSecondaryLogoHD</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Small application logo formatted for display in overhang top left</td>\\n<td>pkg:/images/co_logo_hd.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSecondaryLogoOffsetHD_X</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films. Range 0 to 1280</td>\\n<td>25</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSecondaryLogoOffsetHD_Y</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films. Range 0 to 720</td>\\n<td>50</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSecondaryLogoOffsetSD_X</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films. Range 0 to 720</td>\\n<td>25</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSecondaryLogoOffsetSD_Y</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Offset in pixels from the top-left origin of the display films. Range 0 to 480</td>\\n<td>50</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSecondaryLogoSD</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>Small application logo formatted for display in overhang top left</td>\\n<td>pkg:/images/co_logo_sd.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSliceHD</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>URI for the overhang slice (thin piece of border at the top of the screen in HD size)</td>\\n<td>pkg:/images/overhang_hd.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>OverhangSliceSD</td>\\n<td>Co Ke Li Pa Po Se Sp Te</td>\\n<td>URI for the overhang slice (thin piece of top of screen border)</td>\\n<td>pkg:/images/overhang_sd.png</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>ParagraphBodyText</td>\\n<td>Co Pa Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>ParagraphHeaderText</td>\\n<td>Co Pa Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>PosterScreenLine1Text</td>\\n<td>Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>PosterScreenLine2Text</td>\\n<td>Po</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>RegistrationCodeColor</td>\\n<td>Co</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>RegistrationFocalColor</td>\\n<td>Co</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>RegistrationFocalRectColor</td>\\n<td>Co</td>\\n<td>HTML HEX Color Value</td>\\n<td>#10FF80</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>RegistrationFocalRectHD</td>\\n<td>Co</td>\\n<td>Position and size of the HD focal rectangle. Four integer: (x,y,width,height)</td>\\n<td>(228,360,120,82)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>RegistrationFocalRectSD</td>\\n<td>Co</td>\\n<td>Position and size of the SD focal rectangle. Four integer: (x,y,width,height)</td>\\n<td>(172,220,90,76)</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>SpringboardActorColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardAlbumColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardAlbumLabel</td>\\n<td>Sp</td>\\n<td>Album Label</td>\\n<td>on</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardAlbumLabelColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardAllow6Buttons</td>\\n<td>Sp</td>\\n<td>boolean string</td>\\n<td>true</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>SpringboardArtistColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardArtistLabel</td>\\n<td>Sp</td>\\n<td>Artist Label</td>\\n<td>by</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardArtistLabelColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardDirectorColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardDirectorText</td>\\n<td>Sp</td>\\n<td>Director Label</td>\\n<td>Written by</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardDirectorLabelColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardDirectorPrefixText</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td></td>\\n</tr>\\n<tr>\\n<td>SpringboardGenreColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardRuntimeColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardSynopsisColor</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>SpringboardTitleText</td>\\n<td>Sp</td>\\n<td>HTML HEX Color Value</td>\\n<td>#FF00FF</td>\\n<td>1.0</td>\\n</tr>\\n<tr>\\n<td>TextScreenBodyBackgroundColor</td>\\n<td>Te</td>\\n<td>HTML HEX Color Value. Must be a grayscale value</td>\\n<td>#808080</td>\\n<td>4.3</td>\\n</tr>\\n<tr>\\n<td>TextScreenBodyText</td>\\n<td>Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#363636</td>\\n<td>4.3</td>\\n</tr>\\n<tr>\\n<td>TextScreenScrollBarColor</td>\\n<td>Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#CC0000</td>\\n<td>4.3</td>\\n</tr>\\n<tr>\\n<td>TextScreenScrollThumbColor</td>\\n<td>Te</td>\\n<td>HTML HEX Color Value</td>\\n<td>#00CC00</td>\\n<td>4.3</td>\\n</tr>\\n<tr>\\n<td>ThemeType</td>\\n<td></td>\\n<td>Theme type. Generic-dark is the only valid value. Otherwise the default theme applies</td>\\n<td>generic-dark</td>\\n<td>2.7</td>\\n</tr>\\n</tbody>\\n</table>\\n<p><strong>Example</strong></p>\\n<pre><code>Sub SetApplicationTheme()\\n    app = CreateObject(\\\"roAppManager\\\")\\n    theme = CreateObject(\\\"roAssociativeArray\\\")\\n    theme.OverhangSliceHD = \\\"pkg:/images/Overhang_Slice_HD.png\\\"\\n    theme.OverhangPrimaryLogoSD = \\\"pkg:/images/Logo_Overhang_SD43.png\\\"\\n    theme.OverhangPrimaryLogoOffsetSD_X = \\\"72\\\"\\n    theme.OverhangPrimaryLogoOffsetSD_Y = \\\"25\\\"\\n    theme.OverhangPrimaryLogoHD = \\\"pkg:/images/Logo_Overhang_HD.png\\\"\\n    theme.OverhangPrimaryLogoOffsetHD_X = \\\"123\\\"\\n    theme.OverhangPrimaryLogoOffsetHD_Y = \\\"48\\\"\\n    app.SetTheme(theme)\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifappmanager.md\\\" title=\\\"ifAppManager\\\">ifAppManager</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roarray.md":"{\n  \"content\": \"<h1 id=\\\"roarray\\\">roArray</h1>\\n<p>An array stores an indexed collection of BrightScript objects. Each entry of an array can be a different type, or they may all of the same type.</p>\\n<p>An roArray is created with two parameters:</p>\\n<p><strong>CreateObject(\\\"roArray\\\", size As Integer, resizeAs Boolean)</strong></p>\\n<p>Size is the initial number of elements allocated for the array. If resize is true, the array will be resized if needed to accommodate more elements. If the array is large, this might be slow.\\nThe \\\"dim\\\" statement may be used instead of CreateObject to allocate a new array. Dim has the advantage in that it automatically creates arrays of arrays for multi-dimensional arrays.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarray.md\\\" title=\\\"ifArray\\\">ifArray</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarrayget.md\\\" title=\\\"ifArrayGet\\\">ifArrayGet</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarrayset.md\\\" title=\\\"ifArraySet\\\">ifArraySet</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifenum.md\\\" title=\\\"ifEnum\\\">ifEnum</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarrayjoin.md\\\" title=\\\"ifArrayJoin\\\">ifArrayJoin</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarraysort.md\\\" title=\\\"ifArraySort\\\">ifArraySort</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roassociativearray.md":"{\n  \"content\": \"<h1 id=\\\"roassociativearray\\\">roAssociativeArray</h1>\\n<p>An associative array (also known as a map, dictionary or hash table) allows objects to be associated with string keys. Associative arrays are built into the language. They can be accessed implicitly by using the dot or bracket operators, or by calling functions from the <a href=\\\"/docs/references/brightscript/interfaces/ifassociativearray.md\\\" title=\\\"ifAssociativeArray\\\">ifAssociativeArray</a> interface. For example, the last three lines in this example are equivalent:</p>\\n<pre><code>aa = { one : 1, two : 2, three : 3 }\\nx = aa[\\\"two\\\"]\\nx = aa.two\\nx = aa.Lookup(\\\"two\\\")\\n</code></pre>\\n<p>This object is created with no parameters:</p>\\n<pre><code>CreateObject(\\\"roAssociativeArray\\\")\\n</code></pre>\\n<p>It can also be created implicitly by using an Associative Array literal.</p>\\n<p>Starting from Roku OS 8, the quoted keys in Associative Array literals are now case-preserving. This change improves the readability of your code and is compatible with JSON usage.</p>\\n<p><strong>Example</strong></p>\\n<pre><code>' Creation of associative arrays\\n\\naa1 = CreateObject(\\\"roAssociativeArray\\\")   ' Explicitly \\naa2 = {}                                   ' Implicitly\\naa3 = {                                    ' With some initial values\\n   foo : 12,\\n   bar : 13\\n}\\n\\n' Assigning values\\n\\naa1.AddReplace(\\\"Bright\\\", \\\"Script\\\")  ' With explicit function calls\\naa1.AddReplace(\\\"TMOL\\\", 42)\\naa1.boo = 112                       ' With dot operator\\naa1[\\\"baz\\\"] = \\\"abcdefg\\\"              ' With bracket operator\\n\\n' Accessing values\\n\\nprint aa1.Bright           ' With dot operator (will print 'Script')\\nprint aa1.Lookup(\\\"TMOL\\\")   ' With function call (will print 42)\\nprint aa1[\\\"boo\\\"]           ' With bracket operator (will print 112)\\n\\n' Using ifEnum interface to walk through keys in an associative array\\nfor each key in aa1\\n\\n    print \\\"  \\\" key \\\"=\\\" aa1[key]\\n\\nend for\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifassociativearray.md\\\">ifAssociativeArray</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifenum.md\\\">ifEnum</a>             </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roaudioguide.md":"{\n  \"content\": \"<h1 id=\\\"roaudioguide\\\">roAudioGuide</h1>\\n<blockquote>\\n<p>This component is only available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.5 and later.</p>\\n</blockquote>\\n<p>The roAudioGuide component provides Audio Guide support for applications that require custom speech beyond what is provided by automatic Audio Guide in SDK and Scene Graph components.</p>\\n<p>Though some of the roAudioGuide API is similar to <a href=\\\"/docs/references/brightscript/components/rotexttospeech.md\\\" title=\\\"roTextToSpeech\\\">roTextToSpeech</a>, roAudioGuide provides support specific to Audio Guide, including:</p>\\n<ul>\\n<li>Speaks when Audio Guide is enabled, and doesn't speak if it isn't.</li>\\n<li>Automatically splits up text to reduce lag.</li>\\n<li>Uses the correct voice, language, volume, and speech rate for Audio Guide.</li>\\n<li>Tries to be \\\"smart\\\" by pre-processing the text for correct pronunciation of things like currency, email addresses, acronyms, media-related names and titles, etc.</li>\\n</ul>\\n<p>Usually, roAudioGuide would be used on its own, but it can be used in conjunction with <a href=\\\"/docs/references/brightscript/components/rotexttospeech.md\\\" title=\\\"roTextToSpeech\\\">roTextToSpeech</a>.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifaudioguide.md\\\" title=\\\"ifAudioGuide\\\">ifAudioGuide</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roaudiometadata.md":"{\n  \"content\": \"<h1 id=\\\"roaudiometadata\\\">roAudioMetadata</h1>\\n<p>The roAudioMetadata component provides developers access to audio file metadata included in many audio files. This should enable some audiofiles to deliver the information needed to fill out an roSpringboard screen without passing the info in a separate xml feed. roAudioMetadata currently only works with local file URLs. </p>\\n<p>The component requires the use of a dynamically loaded library that is not part of the initially booted image. Therefore, an entry must be added to the manifest of any applications that use the roAudioMetadata component so it can be loaded when the channel is launched. Here's the manifest entry:</p>\\n<p><em>requires_audiometadata=1</em></p>\\n<p>This object is created without any arguments:</p>\\n<p><code>CreateObject(\\\"roAudioMetadata\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>REM printAA() is from generalUtils.brs in our sample apps\\nREM and used to print an associative Array\\n\\nSub SaveCoverArtFile(filename As String)\\n    meta = CreateObject(\\\"roAudioMetadata\\\")\\n    meta.SetUrl(filename)\\n    print \\\"------------- GetTags() -------------------------\\\"\\n    tags = meta.GetTags()\\n    printAA(tags)\\n    print \\\"------------- GetAudioProperties() --------------\\\"\\n    properties = meta.GetAudioProperties()\\n    printAA(properties)\\n    print \\\"------------- GetCoverArt() ---------------------\\\"\\n    thumbnail = meta.GetCoverArt()\\n    if (thumbnail &#x3C;> invalid) then\\n            if (thumbnail.bytes = invalid) then\\n            return\\n        end if\\n        imgtype = thumbnail.type\\n        image_ext=\\\"\\\"\\n        if (imgtype = \\\"image/jpeg\\\" or imgtype = \\\"jpg\\\") then\\n            image_ext = \\\"jpg\\\"\\n        else if (imgtype = \\\"image/png\\\" or imgtype = \\\"png\\\") then\\n            image_ext = \\\"png\\\"\\n        else\\n            image_ext = \\\"jpg\\\"\\n        end if\\n        tmp_img = \\\"tmp:/CoverArtImage\\\" + \\\".\\\" + image_ext\\n        if (tmp_img &#x3C;> invalid) then\\n            DeleteFile(tmp_img)\\n        end if\\n        thumbnail.bytes.Writefile(tmp_img)\\n    end if\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifaudiometadata.md\\\" title=\\\"ifAudioMetadata\\\">ifAudioMetadata</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roaudioplayer.md":"{\n  \"content\": \"<h1 id=\\\"roaudioplayer\\\">roAudioPlayer</h1>\\n<p>The Audio Player object provides the ability to setup the playing of a series of audio streams. The object accepts an array of content meta-data objects, describing the audio and providing url's for accessing each stream. The component understands the following streamformat values: \\\"mp3\\\", \\\"wma\\\", \\\"mp4\\\", \\\"hls\\\", \\\"es.aac-adts\\\", \\\"flac.\\\"</p>\\n<p>This object does not provide an interface to a screen. In order to get events both from the screen you are using and the Audio Player, you should use the same Message Port for both objects. </p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roAudioPlayer\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>Sub Main()\\n    audioPlayer = CreateObject(\\\"roAudioPlayer\\\")\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    audioPlayer.SetMessagePort(port)\\n    song = CreateObject(\\\"roAssociativeArray\\\")\\n    song.url = \\\"http://www.theflute.co.uk/media/BachCPE_SonataAmin_1.wma\\\"\\n    audioplayer.addcontent(song)\\n    audioplayer.setloop(false)\\n    audioPlayer.play()\\n    while true\\n            msg = wait(0, port)\\n            if type(msg) = \\\"roAudioPlayerEvent\\\"\\n                    if msg.isStatusMessage() then\\n                        print \\\"roAudioPlayerEvent: \\\"; msg.getmessage()\\n                        if msg.getmessage() = \\\"end of playlist\\\" return\\n                    endif\\n            endif\\n        end while\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifaudioplayer.md\\\" title=\\\"ifAudioPlayer\\\">ifAudioPlayer</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/roaudioplayerevent.md\\\" title=\\\"roAudioPlayerEvent\\\">roAudioPlayerEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roaudioresource.md":"{\n  \"content\": \"<h1 id=\\\"roaudioresource\\\">roAudioResource</h1>\\n<p>The roAudioResouce allows .wav files to be cached to memory and quickly played at any time. roAudioResource is intended to support short audio clips which need to be played with very little latency. The system caches the entire wav file in memory so that playback can begin very quickly.</p>\\n<p>On Roku \\\"Classic\\\" models, roAudioResource does not support mixing of sounds. So when you play a sound effect, any background music is paused while the sound effect plays and then resumes after the sound effect ends. On later models, sound effects are mixed with background music. See the <a href=\\\"/docs/specs/hardware.md#current-models\\\">Hardware specifications document</a> for a list of Current and Classic models.</p>\\n<p>This object is created with a filename parameter that is a path to the sound resource file:</p>\\n<p><code>CreateObject(\\\"roAudioResource\\\", filename)</code></p>\\n<p>The filename must be the name of a local file and cannot be a URL. To use a URL, you may download the file to the application's \\\"tmp:\\\" file system using <a href=\\\"/docs/references/brightscript/components/rourltransfer.md\\\">roUrlTransfer</a> and pass a filename of the form \\\"tmp:/file.wav\\\" to CreateObject.</p>\\n<pre><code>sound = CreateObject(\\\"roAudioResource\\\", \\\"pkg:/sounds/beep1.wav\\\")\\nsound.Trigger(75)\\n</code></pre>\\n<p>An object can also be created using the name of a system sound effect:</p>\\n<ul>\\n<li>\\\"select\\\" - the sound effect to be played when a selection is made, e.g. when OK is pressed.</li>\\n<li>\\\"navsingle\\\" - the sound effect to be played when navigating a list or grid, e.g. when left or right is pressed.</li>\\n<li>\\\"navmulti\\\" - the sound effect to be played when paging through a list or grid, e.g. when rewind or fast-forward is pressed.</li>\\n<li>\\\"deadend\\\" - the sound effect to be played when a button press could not be processed.</li>\\n</ul>\\n<p>Note that system sound effects are played at the volume selected in the user's settings, or not played at all if the user has turned sound effects off, regardless of the volume value passed to Trigger.</p>\\n<pre><code>sound = CreateObject(\\\"roAudioResource\\\", \\\"select\\\")\\nsound.Trigger(50)\\n</code></pre>\\n<p>Mult\\niple sounds can be mixed and played at the same time:</p>\\n<pre><code>sound1 = CreateObject(\\\"roAudioResource\\\", \\\"pkg:/sounds/beep1.wav\\\")\\nsound2 = CreateObject(\\\"roAudioResource\\\", \\\"select\\\")\\nsound1.Trigger(50, 0)\\nif sound2.maxSimulStreams() > 1\\n  sound2.Trigger(50, 1)\\nend if\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported Interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifaudioresource.md\\\">ifAudioResource</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/robitmap.md":"{\n  \"content\": \"<h1 id=\\\"robitmap\\\">roBitmap</h1>\\n<p>The roBitmap component contains image data and provides an interface (ifDraw2D) for drawing. Bitmaps can be used for a variety of purposes, such as for sprites, compositing, or as double buffers.</p>\\n<p>It stores four color channels: red, green, blue, and alpha, with 32-bits per pixel. They can be any arbitrary size up to 2048x2048. However, the maximum size bitmap uses 16MB of memory, so there are practical memory limitations which would compel smaller bitmap sizes.  Coordinates (x,y) for 2D bitmaps have an origin (0,0) at the top left. roBitmap is always offscreen. The top roScreen is the only ifDraw2D surface which is displayed. roBitmap represents something that can be drawn onto, as well as something that can be drawn.</p>\\n<p>Drawing operations into a roBitmap (or other surface with ifDraw2D interface, such as an <a href=\\\"/docs/references/brightscript/components/roscreen.md\\\" title=\\\"roScreen\\\">roScreen</a>) are clipped so the only the part that is within its bounds is rendered. X,Y coordinates that specify a location in a bitmap to render to (for example, as used by DrawObject() or DrawText() ) may be positive or negative. Negative implies that the left and top of the rendered object will be clipped.The same bitmap cannot be used as a source and a destination in a single DrawObject() call.</p>\\n<p>There are limitations when using the onscreen bitmap as a source. For example, Alpha blending may not work.</p>\\n<p>An empty roBitmap object can be created with CreateObject():</p>\\n<p><code>CreateObject(\\\"roBitmap\\\", bitmapProps As Object)</code></p>\\n<p>bitmapProps is an roAssociativeArray with Integers width (Integer), height (Integer), and AlphaEnable (Boolean), and name (String) parameters. The contents of an empty RoBitmap are initialized to zero (transparent black).</p>\\n<p>Example: <code>CreateObject(\\\"roBitmap\\\", {width:10, height:10, AlphaEnable:false, name:\\\"MyBitmapName\\\"})</code></p>\\n<p>An roBitmap can also load its image data from a file:</p>\\n<p><code>CreateObject(\\\"roBitmap\\\", String filename)</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>' Draw three bitmaps as fast as we can\\n'\\nScreen=CreateObject(\\\"roScreen\\\")\\nbm1=CreateObject(\\\"roBitmap\\\", \\\"pkg:/images/myphoto1.jpg\\\")\\nbm2=CreateObject(\\\"roBitmap\\\", \\\"pkg:/images/myphoto2.jpg\\\")\\nbm3=CreateObject(\\\"roBitmap\\\", \\\"pkg:/images/myphoto3.jpg\\\")\\nbmarray=[bm1, bm2, bm3]\\nWhile true\\n    For each bitmap in bmarray\\n        Screen.DrawObject(0,0, bitmap)\\n        Screen.Finish()\\n    End for\\nEnd While\\n</code></pre>\\n<p><strong>Example: Double buffering with roBitmap</strong></p>\\n<pre><code>screen1=CreateObject(\\\"roScreen\\\")\\noff=CreateObject(\\\"roBitmap\\\", {width:1280, height:720, AlphaEnable:false})\\noff.Clear(white)\\ndfDrawImage(off, \\\"pkg:/images/myimage.png\\\", 50, 50)\\noff.DrawRect(150, 150, 200, 200, &#x26;hFF) ' black, alpha: all source\\nscreen1.DrawObject(0, 0, off)\\nScreen1.Finish()\\n</code></pre>\\n<h2 id=\\\"supported-image-formats\\\">Supported image formats</h2>\\n<p>See the <a href=\\\"/docs/specs/media/streaming-specifications.md#supported-image-formats\\\">Roku streaming specification</a> for the image formats supported by this component. </p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifdraw2d.md\\\" title=\\\"ifDraw2D\\\">ifDraw2D</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roboolean.md":"{\n  \"content\": \"<h1 id=\\\"roboolean\\\">roBoolean</h1>\\n<p>roBoolean is the object equivalent for intrinsic type Boolean. </p>\\n<p>This is useful in the following situations:</p>\\n<ul>\\n<li>When an object is needed, instead of an intrinsic value. For example, \\\"roList\\\" maintains a list of objects. If an Boolean is added to roList, it will be automatically wrapped in an roBoolean by the language interpreter. When a function that expects a BrightScript Component as a parameter is passed a boolean, BrightScript automatically creates the equivalent BrightScript Component.</li>\\n<li>If any object exposes the ifBoolean interface, that object can be used in any expression that expects an intrinsic value.</li>\\n</ul>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifboolean.md\\\" title=\\\"ifBoolean\\\">ifBoolean</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/robytearray.md":"{\n  \"content\": \"<h1 id=\\\"robytearray\\\">roByteArray</h1>\\n<p>The byte array component is used to contain and manipulate an arbitrary array of bytes. </p>\\n<p>This object contains functions to convert strings to or from a byte array, as well as to or from ascii hex or ascii base 64. Note that if you are converting a byte array to a string, and the byte array contains a zero, the string conversion will end at that point. roByteArray will autosize to become larger as needed. If you wish to turn off this behavior, then use the SetResize() function. If you read an uninitialized index, \\\"invalid\\\" is returned.\\nroByteArray supports the <a href=\\\"/docs/references/brightscript/interfaces/ifarray.md\\\" title=\\\"ifArray\\\">ifArray</a> interface, and so can be accessed with the array [] operator. The byte array is always accessed as unsigned bytes when using this interface. roByteArray also supports the ifEnum interface, and so can be used with a \\\"for each\\\" statement.</p>\\n<p><strong>Example</strong></p>\\n<pre><code>ba=CreateObject(\\\"roByteArray\\\")\\nba.FromAsciiString(\\\"leasure.\\\")\\nif ba.ToBase64String()&#x3C;>\\\"bGVhc3VyZS4=\\\" then stop\\n\\nba=CreateObject(\\\"roByteArray\\\")\\nba.fromhexstring(\\\"00FF1001\\\")\\nif ba[0]&#x3C;>0 or ba[1]&#x3C;>255 or ba[2]&#x3C;>16 or ba[3]&#x3C;>1 then stop\\n\\nba=CreateObject(\\\"roByteArray\\\")\\nfor x=0 to 4000\\n    ba.push(x)\\nend for\\n\\nba.WriteFile(\\\"tmp:/ByteArrayTestFile\\\")\\nba2=CreateObject(\\\"roByteArray\\\")\\nba2.ReadFile(\\\"tmp:/ByteArrayTestFile\\\")\\nif ba.Count()&#x3C;>ba2.Count() then stop\\nfor x=0 to 4000\\n    if ba[x]&#x3C;>ba2[x] then stop\\nend for\\n\\nba2.ReadFile(\\\"tmp:/ByteArrayTestFile\\\", 10, 100)\\nif ba2.count()&#x3C;>100 then stop\\nfor x=10 to 100\\n    if ba2[x-10]&#x3C;>x then stop\\nend for\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifbytearray.md\\\" title=\\\"ifByteArray\\\">ifByteArray</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarray.md\\\" title=\\\"ifArray\\\">ifArray</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarrayget.md\\\" title=\\\"ifArrayGet\\\">ifArrayGet</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarrayset.md\\\" title=\\\"ifArraySet\\\">ifArraySet</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifenum.md\\\" title=\\\"ifEnum\\\">ifEnum</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rocaptionrenderer.md":"{\n  \"content\": \"<h1 id=\\\"rocaptionrenderer\\\">roCaptionRenderer</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The roCaptionRenderer component provides a mechanism for BrightScript channels to render closed captions in video played back with the roVideoPlayer. Prior to the v 5.2 Roku firmware, captions could only be rendered in roVideoScreen.</p>\\n<p>Prior to the 5.2 Roku OS version, closed captions could only be rendered in roVideoScreen.  Now channels that use roVideoPlayer embedded in an roScreen or roImageCanvas can also take advantage of Roku's closed captioning support.  roCaptionRenderer supports two different modes, which is set using the <a href=\\\"/docs/references/brightscript/interfaces/ifcaptionrenderer.md#setmodemode-as-integer-as-void\\\" title=\\\"SetMode()\\\">SetMode()</a> method.  Depending on the mode set, and the type of screen being used, the BrightScript channel needs to do different levels of work to render captions.  These different workflows are highlighted in the tables below:</p>\\n<p><strong>Model 1</strong></p>\\n<table>\\n<thead>\\n<tr>\\n<th>roScreen</th>\\n<th>roImageCanvas</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Call <a href=\\\"/docs/references/brightscript/interfaces/ifcaptionrenderer.md#setscreenscreen-as-object-as-void\\\" title=\\\"SetScreen()\\\">SetScreen()</a></td>\\n<td>Call <a href=\\\"/docs/references/brightscript/interfaces/ifcaptionrenderer.md#setscreenscreen-as-object-as-void\\\" title=\\\"SetScreen()\\\">SetScreen()</a></td>\\n</tr>\\n<tr>\\n<td>Call <a href=\\\"/docs/references/brightscript/interfaces/ifcaptionrenderer.md#updatecaption-as-void\\\" title=\\\"UpdateCaption()\\\">UpdateCaption()</a></td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<p><strong>Model 2</strong></p>\\n<table>\\n<thead>\\n<tr>\\n<th>roScreen</th>\\n<th>roImageCanvas</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>All caption rendering is done by the channel's BrightScript code</td>\\n<td>All caption rendering is done by the channel's BrightScript code</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>BrightScript channels do not create roCaptionRenderer instances directly using CreateObject().  Instead, when an roVideoPlayer is created, it contains an roCaptionRenderer.  BrightScript channels call <a href=\\\"/docs/references/brightscript/interfaces/ifvideoplayer.md#getcaptionrenderer-as-object\\\" title=\\\"ifVideoPlayer.GetCaptionRenderer()\\\">ifVideoPlayer.GetCaptionRenderer()</a> to get the caption renderer associated with their video player.</p>\\n<p><strong>Example</strong></p>\\n<pre><code>Function Main() as void\\n  mode = 1\\n  fonts = CreateObject(\\\"roFontRegistry\\\")\\n  fonts.Register(\\\"pkg:/fonts/vSHandprinted.otf\\\")\\n  font = fonts.GetFont(\\\"vSHandprinted\\\", 28, 500, false)\\n  screen = CreateObject(\\\"roScreen\\\", true)\\n  port = CreateObject(\\\"roMessagePort\\\")\\n  screen.Clear(&#x26;h00)\\n  screen.SwapBuffers()\\n  screen.SetMessagePort(port)\\n  timer = CreateObject(\\\"roTimespan\\\")\\n  screenSize = {}\\n  screenSize.width = screen.GetWidth()\\n  screenSize.height = screen.GetHeight()\\n\\n  player = CreateObject(\\\"roVideoPlayer\\\")\\n  player.SetContentList([\\n    {\\n        Stream : { url :\\\"http://ecn.channel9.msdn.com/o9/content/smf/smoothcontent/elephantsdream/Elephants_Dream_1024-h264-st-aac.ism/manifest\\\" }\\n        StreamFormat : \\\"ism\\\"\\n        TrackIDAudio: \\\"audio_eng\\\"\\n        TrackIDSubtitle: \\\"ism/textstream_eng\\\"\\n    }\\n  ])\\n\\n  captions = player.GetCaptionRenderer()\\n  if (mode = 1)\\n    captions.SetScreen(screen)\\n  endif\\n  captions.SetMode(mode)\\n  captions.SetMessagePort(port)\\n  captions.ShowSubtitle(true)\\n\\n  player.play()\\n\\n  while true\\n    msg = wait(250, port)\\n    if type(msg) = \\\"roCaptionRendererEvent\\\"\\n      if msg.isCaptionText()\\n        print \\\"isCaptionText\\\"\\n        if msg.GetMessage() &#x3C;> invalid and msg.GetMessage() &#x3C;> \\\"\\\"\\n          DrawCaptionString(screen, screenSize, msg.GetMessage(), font)\\n          timer.Mark()\\n        else if timer.TotalSeconds() > 2\\n          ClearCaptionString(screen)\\n        endif\\n      else if msg.isCaptionUpdateRequest()\\n        print \\\"isCaptionUpdateRequest()\\\"\\n        UpdateCaptions(screen, captions)\\n      end if\\n    endif\\n  end while\\nEnd Function\\n\\nFunction UpdateCaptions(screen as object, captions as object) as Void\\n  screen.Clear(&#x26;h00)\\n  captions.UpdateCaption()\\n  screen.SwapBuffers()\\nEnd Function\\n\\nFunction DrawCaptionString(screen as object, screenSize as object, caption as String, font as object) as Void\\n  screen.Clear(&#x26;h00)\\n  textHeight = font.GetOneLineHeight()\\n  textWidth = font.GetOneLineWidth(caption, screenSize.width)\\n  x = (screenSize.width - textWidth) / 2\\n  y = screenSize.height - textHeight\\n  screen.DrawText(caption, x, y, &#x26;hd5d522ff, font)\\n  screen.SwapBuffers()\\nEnd Function\\n\\nFunction ClearCaptionString(screen as object) as void\\n  screen.Clear(&#x26;h00)\\n  screen.SwapBuffers()\\nEnd Function\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifcaptionrenderer.md\\\" title=\\\"ifCaptionRenderer\\\">ifCaptionRenderer</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/event/rocaptionrendererevent.md\\\" title=\\\"roCaptionRendererEvent\\\">roCaptionRendererEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rochannelstore.md":"{\n  \"content\": \"<h1 id=\\\"rochannelstore\\\">roChannelStore</h1>\\n<p>The roChannelStore component allows the application to perform a purchase of an In-Channel Product or upgrade a channel. Most of the purchase flow, screens and messaging associated with the financial transaction are handled by the Roku OS outside of control or monitoring by BrightScript code. The BrightScript code merely initiates the purchase and receives a final result. This will engender trust with users and give them confidence that they are dealing with the Roku Channel Store.</p>\\n<p>The roChannelStore component allows purchasing only those In-Channel Products which are associated with the running channel. Please see <a href=\\\"/docs/developer-program/roku-pay/quickstart/in-channel-products.md\\\" title=\\\"Adding in-channel products\\\">Adding in-channel products</a> for details on how to create an In-Channel Product and associate it with a channel. After one or Products are created, GetCatalog() can be used to retrieve a list of Products and their attributes. DoOrder() can be called to initiate a purchase of one or more of the Products.</p>\\n<p>The roChannelStore object has a FakeServer() method that will enable you to test the purchase flow scenarios without actually making a real transaction in the Roku channel store. This will be useful in the development of your channel, but should never be used in the actual channel you publish.</p>\\n<p>This object is created without any arguments:</p>\\n<p><code>CreateObject(\\\"roChannelStore\\\")</code></p>\\n<blockquote>\\n<p>Because <a href=\\\"/docs/references/brightscript/interfaces/ifchannelstore.md#doorder-as-boolean\\\" title=\\\"ifChannelStore.DoOrder()\\\">ifChannelStore.DoOrder()</a> needs to read the product type returned by GetCatalog(), only one instance of roChannelStore should ever be used for a complete purchase flow - you should never create a separate roChannelStore object to complete a purchase that was initiated by a different instance of roChannelStore.</p>\\n</blockquote>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifchannelstore.md\\\" title=\\\"ifChannelStore\\\">ifChannelStore</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort \\\">ifGetMessagePort </a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rochannelstoreevent.md\\\" title=\\\"roChannelStoreEvento\\\">roChannelStoreEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rocoderegistrationscreen.md":"{\n  \"content\": \"<h1 id=\\\"rocoderegistrationscreen\\\">roCodeRegistrationScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Code Registration Screen is designed to present the user a registration code, and the information required to instruct the user on how to register with a service provider. This screen is designed for a rendezvous registration process, where the user is presented a code and the URL for a registration site. The user goes to the site and enters their code, which causes the device and the account to be linked. In the background, the script is polling for completion and the screen is closed to display an activation successful screen when done.</p>\\n<p><strong>Diagram: roCodeRegistrationScreen</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roCodeRegistrationScreenImage1.png\\\" alt=\\\"Diagram: roCodeRegistrationScreen\\\" title=\\\"roCodeRegistrationScreenImage1\\\"></p>\\n<p><strong>Example</strong></p>\\n<pre><code>Function ShowMessageDialog() As Void\\n     port = CreateObject(\\\"roMessagePort\\\")\\n     screen = CreateObject(\\\"roCodeRegistrationScreen\\\")\\n     screen.SetMessagePort(port)\\n     screen.SetTitle(\\\"[Registration screen title]\\\")\\n     screen.AddParagraph(\\\"[Registration screen paragraphs are justified to right and left edges]\\\")\\n     screen.AddFocalText(\\\" \\\", \\\"spacing-dense\\\")\\n     screen.AddFocalText(\\\"From your computer,\\\", \\\"spacing-dense\\\")\\n     screen.AddFocalText(\\\"go to www.myco.com/roku\\\", \\\"spacing-dense\\\")\\n     screen.AddFocalText(\\\"and enter this code:\\\", \\\"spacing-dense\\\")\\n     screen.AddFocalText(\\\" \\\", \\\"spacing-dense\\\")\\n     screen.SetRegistrationCode(\\\"retrieving code...\\\")\\n     screen.AddParagraph(\\\"[Registration screen paragraphs are justified to right and left edges and may continue on multiple lines]\\\")\\n     screen.AddButton(0, \\\"get a new code\\\")\\n     screen.AddButton(1, \\\"back\\\")\\n     screen.Show()\\n     sleep (10000) 'simulate fetching registration code from webapi\\n     screen.SetRegistrationCode(\\\"ABC7TG\\\")\\n     screen.Show()\\n     while true\\n         dlgMsg = wait(0, dialog.GetMessagePort())\\n         exit while\\n     end while\\n End Function\\n</code></pre>\\n<p><strong>Image: roCodeRegistrationScreen example results</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/cdregistscrn1.jpg\\\" alt=\\\"cdregistscrn1\\\" title=\\\"cdregistscrn1\\\"></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/cdregistscrn2.jpg\\\" alt=\\\"cdregistscrn2\\\" title=\\\"cdregistscrn2\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iifCodeRegistrationScreen.md\\\" title=\\\"ifCodeRegistrationScreen\\\">ifCodeRegistrationScreen</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifsetmessageport \\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rocoderegistrationscreenevent.md\\\" title=\\\"roCodeRegistrationScreenEvent\\\">roCodeRegistrationScreenEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rocompositor.md":"{\n  \"content\": \"<h1 id=\\\"rocompositor\\\">roCompositor</h1>\\n<p>The roCompositor allows the composition and animation of multiple roBitmaps and roRegions.</p>\\n<p>This object can create and manage roSprites in a z-ordered list. The sprites can be of arbitrary size and can be thought of as planes. The compositor can manage collision detection between the sprites, support scrolling the sprite bitmap source, and support animated sprites (multi-frame sprites with frame-flipping animation). You may have multiple roCompositor components, and they can composite onto the same or separate bitmaps. That said, the most common scenario is to have a single roCompositor.</p>\\n<p><strong>Example: Scrolling a bitmap</strong></p>\\n<pre><code>Library \\\"v30/bslCore.brs\\\"\\nFunction main()\\n        black=&#x26;hFF'RGBA\\n        screen=CreateObject(\\\"roScreen\\\")\\n        compositor=CreateObject(\\\"roCompositor\\\")\\n        compositor.SetDrawTo(screen, black)\\n        http = CreateObject(\\\"roUrlTransfer\\\")\\n        http.SetMessagePort(CreateObject(\\\"roMessagePort\\\"))\\n        http.SetUrl(\\\"http://rokudev.roku.com/rokudev/examples/scroll/VeryBigPng.png\\\")\\n        http.AsyncGetToFile(\\\"tmp:/VeryBigPng.png\\\")\\n        wait(0, http.GetPort())\\n        bigbm=CreateObject(\\\"roBitmap\\\",\\\"tmp:/VeryBigPng.png\\\")\\n        region=CreateObject(\\\"roRegion\\\", bigbm, 0, 0, 1280, 720)\\n        region.SetWrap(True)\\n\\n        view_sprite=compositor.NewSprite(0, 0, region)\\n        compositor.draw()\\n        screen.SwapBuffers()\\n        msgport = CreateObject(\\\"roMessagePort\\\")\\n        screen.SetMessagePort(msgport)\\n        codes = bslUniversalControlEventCodes()\\n        While True\\n                msg=wait(0, msgport) ' wait for a button\\n                print \\\"Msg: \\\"; type(msg); \\\" event: \\\"; msg.GetInt()\\n                If type(msg)=\\\"roUniversalControlEvent\\\" Then\\n                        If msg.GetInt()=codes.BUTTON_UP_PRESSED Then\\n                                Zip(screen, view_sprite, compositor, 0,-4) 'up\\n                        Else If msg.GetInt()=codes.BUTTON_DOWN_PRESSED Then\\n                                Zip(screen, view_sprite, compositor, 0,+4) ' down\\n                        Else If msg.GetInt()=codes.BUTTON_RIGHT_PRESSED Then\\n                                Zip(screen, view_sprite, compositor, +4,0) ' right\\n                        Else If msg.GetInt()=codes.BUTTON_LEFT_PRESSED Then\\n                                Zip(screen, view_sprite, compositor, -4, 0) ' left\\n                        Else If msg.GetInt() = codes.BUTTON_BACK_PRESSED ' back button\\n                                Exit While\\n                        End If\\n                End If\\n        End While\\nEnd Function\\nFunction Zip(screen, view_sprite, compositor, xd, yd)\\n        For x=1 To 60\\n                view_sprite.OffsetRegion(xd, yd, 0, 0)\\n                compositor.draw()\\n                screen.SwapBuffers()\\n        End For\\nEnd Function\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifcompositor.md\\\" title=\\\"ifCompositor\\\">ifCompositor</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rodatagramsocket.md":"{\n  \"content\": \"<h1 id=\\\"rodatagramsocket\\\">roDataGramSocket</h1>\\n<p>The roDataGramSocket component enables Brightscript apps to send and receive UDP packets. The interface is modeled on and works much like standard Berkeley sockets.</p>\\n<p>This object is created without any arguments:</p>\\n<p><code>CreateObject(\\\"roDataGramSocket\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>' UDP 2-way peer-to-peer asynchronous comm on port 54321\\n' periodically sends out a message to a specific address and port\\n' prints any message it receives\\nFunction UDPPeer()\\n    msgPort = createobject(\\\"roMessagePort\\\")\\n    udp = createobject(\\\"roDatagramSocket\\\")\\n    udp.setMessagePort(msgPort) 'notifications for udp come to msgPort\\n    addr = createobject(\\\"roSocketAddress\\\")\\n    addr.setPort(54321)\\n    udp.setAddress(addr) ' bind to all host addresses on port 54321\\n    addr.SetHostName(\\\"10.1.1.1\\\")\\n    udp.setSendToAddress(addr) ' peer IP and port\\n    udp.notifyReadable(true)\\n    timeout = 1 * 10 * 1000 ' ten seconds in milliseconds\\n    deviceName = Createobject(\\\"roDeviceInfo\\\").GetFriendlyName()\\n    message = \\\"Datagram from \\\" + deviceName\\n    udp.sendStr(message)\\n    continue = udp.eOK()\\n    While continue\\n        event = wait(timeout, msgPort)\\n        If type(event)=\\\"roSocketEvent\\\"\\n        If event.getSocketID()=udp.getID()\\n                If udp.isReadable()\\n                    message = udp.receiveStr(512) ' max 512 characters\\n                    print \\\"Received message: '\\\"; message; \\\"'\\\"\\n                End If\\n            End If\\n        Else If event=invalid\\n            print \\\"Timeout\\\"\\n            udp.sendStr(message) ' periodic send\\n        End If\\n    End While\\n    udp.close() ' would happen automatically as udp goes out of scope\\n\\nEnd Function\\n</code></pre>\\n<blockquote>\\n<p>GetDeviceUniqueId() was deprecated in Spring OS 2019.</p>\\n</blockquote>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocket.md\\\" title=\\\"ifSocket\\\">ifSocket</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketasync.md\\\" title=\\\"ifSocketAsync\\\">ifSocketAsync</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketstatus.md\\\" title=\\\"ifSocketStatus\\\">ifSocketStatus</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketoption.md\\\" title=\\\"ifSocketOption\\\">ifSocketOption</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketcastoption.md\\\" title=\\\"ifSocketCastOption \\\">ifSocketCastOption </a></li>\\n</ul>\\n<blockquote>\\n<p>Some legacy Roku OS versions may implement ifSocketCastOption as ifSocketCast.</p>\\n</blockquote>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifappinfo.md\\\" title=\\\"roSocketEvent \\\">roSocketEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rodatetime.md":"{\n  \"content\": \"<h1 id=\\\"rodatetime\\\">roDateTime</h1>\\n<p>The roDateTime provides an interface to obtain the current date/time for the player and manipulate date/times.</p>\\n<p>This component provides several options for obtaining attributes about the date/time. All times are GMT unless they are converted to the system timezone with a call to the method: toLocalTime(). </p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roDateTime\\\")</code></p>\\n<p>The date/time of the object is set to the current system time when the object is created.  The date/time represented by the object can be changed by calling Mark(), FromSeconds(), or FromISO8601String().</p>\\n<p><strong>Example</strong></p>\\n<pre><code>date = CreateObject(\\\"roDateTime\\\")\\nprint \\\"The date is now \\\"; date.AsDateString(\\\"long-date\\\")\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifdatetime.md\\\" title=\\\"ifDateTime\\\">ifDateTime</a></li>\\n</ul>\\n<blockquote>\\n<p>Some Roku OS versions may implement ifDateTime as ifRoDateTime</p>\\n</blockquote>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rodeviceinfo.md":"{\n  \"content\": \"<h1 id=\\\"rodeviceinfo\\\">roDeviceInfo</h1>\\n<p>The Device Info provides an interface to obtain attributes about the device.</p>\\n<p>These attributes are not changeable by the script, but may be queried to obtain values for the player. It is common for scripts to need access to the serial number and model info for negotiating with backend services.</p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roDeviceInfo\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>di = CreateObject(\\\"roDeviceInfo\\\")\\nprint di.GetModel()\\nprint di.GetVersion()\\nprint di.GetChannelClientId()\\n</code></pre>\\n<p><strong>Output</strong></p>\\n<p>The output from the above code would like the following:</p>\\n<pre><code> N1000\\n 999.99E99999X\\n 20E825000036\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifdeviceinfo.md\\\" title=\\\"ifDeviceInfo \\\">ifDeviceInfo</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rodeviceinfoevent.md\\\" title=\\\"roDeviceInfoEvent\\\">roDeviceInfoEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rodouble.md":"{\n  \"content\": \"<h1 id=\\\"rodouble\\\">roDouble</h1>\\n<p>roDouble is the object equivalent for intrinsic type 'Double'.</p>\\n<p>It is a legacy object name, corresponding to the intrinsic Double object.  Applications should use Double literal values and/or Double-typed variables directly.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifdouble.md\\\" title=\\\"ifDouble\\\">ifDouble</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rodevicecrypto.md":"{\n  \"content\": \"<h1 id=\\\"rodevicecrypto\\\">roDeviceCrypto</h1>\\n<p>The roDeviceCrypto component enables you to encrypt and decrypt data on a device using a key that is unique per channel, device, or model. Using a channel key for example, you can encrypt data for a channel so that it may only be decrypted by that same channel. In this case, you could provision credentials or an API key from the cloud to devices securely. With a device key for example, you could implement a secure-storage like algorithm.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifdevicecrypto.md\\\">ifDeviceCrypto</a></li>\\n</ul>\\n<h2 id=\\\"description\\\">Description</h2>\\n<p>roDeviceCryptohas two methods:<code>Encrypt()</code> and<code>Decrypt()</code>. Both methods take a<code>roByteArray</code>and the encryption key type (<code>encType</code>), which is a string that may be set to \\\"channel\\\", \\\"device\\\", or \\\"model\\\".  </p>\\n<p>Both methods return a<code>roByteArray</code>so that you can encrypt plaintext on a Roku device\\nand then decode it, as demonstrated in the following example:  </p>\\n<pre><code>  ' store plaintext to be encrypted in an roByteArray\\n  ba = CreateObject(\\\"roByteArray\\\")\\n  ba.FromAsciiString(\\\"plain text1\\\") \\n\\n  ' create roDeviceCrypto object and specify a device key\\n  dc = CreateObject(\\\"roDeviceCrypto\\\")\\n  encType = \\\"device\\\"\\n\\n  ' encrypt plaintext using the device key and store the encoded data in an roByteArray\\n  encrypted = dc.Encrypt(ba, encType)\\n\\n  ' decode the encrypted data and store the decrypted data in an roByteArray\\n  if encrypted &#x3C;> invalid then\\n    decrypted = dc.Decrypt(encrypted,encType)\\n  end if\\n</code></pre>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roevpcipher.md":"{\n  \"content\": \"<h1 id=\\\"roevpcipher\\\">roEVPCipher</h1>\\n<p>The EVP Cipher component provides an interface to the OpenSSL EVP library of symmetric cipher commands. The EVP library provides a high-level interface to cryptographic functions to implement digital \\\"envelopes\\\".</p>\\n<p>These commands allow data to be encrypted or decrypted using various block and stream ciphers using keys based on passwords or explicitly provided. </p>\\n<p>Some of the ciphers do not have large keys and others have security implications if not used correctly. A beginner is advised to just use a strong block cipher in CBC mode such as bf or des3. All the block ciphers normally use PKCS#5 padding also known as standard block padding. If padding is disabled then the input data must be a multiple of the cipher block length.</p>\\n<blockquote>\\n<p>For additional information on the OpenSSL library of symmetric ciphers see: <a href=\\\"https://www.openssl.org/docs/manmaster/man1/enc.html\\\">https://www.openssl.org/docs/manmaster/man1/enc.html</a>.</p>\\n</blockquote>\\n<p><strong>List of supported ciphers</strong></p>\\n<table>\\n<thead>\\n<tr>\\n<th>Name</th>\\n<th>Cipher</th>\\n<th>Key size (bits)</th>\\n<th>Block size (bits)</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>bf-cbc</td>\\n<td>Blowfish in CBC mode</td>\\n<td>128</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>bf</td>\\n<td>Alias for bf-cbc</td>\\n<td>128</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>bf-cfb</td>\\n<td>Blowfish in CFB mode</td>\\n<td>128</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>bf-ecb</td>\\n<td>Blowfish in ECB mode</td>\\n<td>128</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>bf-ofb</td>\\n<td>Blowfish in OFB mode</td>\\n<td>128</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-cbc</td>\\n<td>DES in CBC mode</td>\\n<td>56</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des</td>\\n<td>Alias for des-cbc</td>\\n<td>56</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-cfb</td>\\n<td>DES in CBC mode</td>\\n<td>56</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ecb</td>\\n<td>DES in ECB mode</td>\\n<td>56</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ofb</td>\\n<td>DES in OFB mode</td>\\n<td>56</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede-cbc</td>\\n<td>Two key triple DES EDE in CBC mode</td>\\n<td>80</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede</td>\\n<td>Two key triple DES EDE in ECB mode</td>\\n<td>80</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede-cfb</td>\\n<td>Two key triple DES EDE in CFB mode</td>\\n<td>80</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede-ofb</td>\\n<td>Two key triple DES EDE in OFB mode</td>\\n<td>80</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede3-cbc</td>\\n<td>Three key triple DES EDE in CBC mode</td>\\n<td>112</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede3</td>\\n<td>Three key triple DES EDE in ECB mode</td>\\n<td>112</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des3</td>\\n<td>Alias for des-ede3-cbc</td>\\n<td>112</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede3-cfb</td>\\n<td>Three key triple DES EDE in CFB mode</td>\\n<td>112</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>des-ede3-ofb</td>\\n<td>Three key triple DES EDE in OFB mode</td>\\n<td>112</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>desx</td>\\n<td>DESX algorithm</td>\\n<td>approx. 119</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>desx-cbc</td>\\n<td>DESX in CBC mode</td>\\n<td>approx. 119</td>\\n<td>64</td>\\n</tr>\\n<tr>\\n<td>aes-[128/192/256]-cbc</td>\\n<td>128/192/256 bit AES in CBC mode</td>\\n<td>128,192,256</td>\\n<td>128</td>\\n</tr>\\n<tr>\\n<td>aes-[128/192/256]</td>\\n<td>Alias for aes-[128/192/256]-cbc</td>\\n<td>128,192,256</td>\\n<td>128</td>\\n</tr>\\n<tr>\\n<td>aes-[128/192/256]-cfb</td>\\n<td>128/192/256 bit AES in 128 bit CFB mode</td>\\n<td>128,192,256</td>\\n<td>128</td>\\n</tr>\\n<tr>\\n<td>aes-[128/192/256]-cfb1</td>\\n<td>128/192/256 bit AES in 1 bit CFB mode</td>\\n<td>128,192,256</td>\\n<td>128</td>\\n</tr>\\n<tr>\\n<td>aes-[128/192/256]-cfb8</td>\\n<td>128/192/256 bit AES in 8 bit CFB mode</td>\\n<td>128,192,256</td>\\n<td>128</td>\\n</tr>\\n<tr>\\n<td>aes-[128/192/256]-ecb</td>\\n<td>128/192/256 bit AES in ECB mode</td>\\n<td>128,192,256</td>\\n<td>128</td>\\n</tr>\\n<tr>\\n<td>aes-[128/192/256]-ofb</td>\\n<td>128/192/256 bit AES in OFB mode</td>\\n<td>128,192,256</td>\\n<td>128</td>\\n</tr>\\n</tbody>\\n</table>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifevpcipher.md\\\" title=\\\"ifEVPCipher\\\">ifEVPCipher</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roevpdigest.md":"{\n  \"content\": \"<h1 id=\\\"roevpdigest\\\">roEVPDigest</h1>\\n<p>The EVP Digest component provides an interface to the OpenSSL EVP library of message digest algorithms. The EVP library provides a high-level interface to cryptographic hash functions.</p>\\n<p>roEVPDigest processes an arbitrary amount of data and generates a hash of the data, using a selected algorithm.</p>\\n<blockquote>\\n<p>For additional information on the OpenSSL library of message digest algorithms see: <a href=\\\"http://www.openssl.org/docs/apps/dgst.html\\\">http://www.openssl.org/docs/apps/dgst.html</a></p>\\n</blockquote>\\n<p><strong>List of Supported Digest Algorithms</strong></p>\\n<ul>\\n<li>md5 - MD5 message digest algorithm (default)</li>\\n<li>sha1 - SHA-1 message digest algorithm</li>\\n<li>sha224 - SHA-2, 224 bit variant</li>\\n<li>sha256 - SHA-2, 256 bit variant</li>\\n<li>sha384 - SHA-2, 384 bit variant</li>\\n<li>sha512 - SHA-2, 512 bit variant</li>\\n</ul>\\n<p><strong>Example: SHA1 Message Digest with roEVPDigest</strong></p>\\n<pre><code>ba = CreateObject(\\\"roByteArray\\\")\\n' ...populate bytearray...\\ndigest = CreateObject(\\\"roEVPDigest\\\")\\ndigest.Setup(\\\"sha1\\\")\\nresult = digest.Process(ba)\\nprint result\\n</code></pre>\\n<p><strong>Example: MD5 Message Digest with roEVPDigest</strong></p>\\n<pre><code>ba1 = CreateOjbect(\\\"roByteArray\\\")\\n' ...populate ba1...\\nba2 = CreateObject(\\\"roByteArray\\\")\\nba2.FromAsciiString(somestring)\\ndigest = CreateObject(\\\"roEVPDigest\\\")\\ndigest.Setup(\\\"md5\\\")\\ndigest.Update(ba1)\\ndigest.Update(ba2)\\nresult = digest.Final()\\nprint result\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifevpdigest.md\\\" title=\\\"ifEVPDigest\\\">ifEVPDigest</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rofilesystem.md":"{\n  \"content\": \"<h1 id=\\\"rofilesystem\\\">roFileSystem</h1>\\n<p>The roFilesystem component implements common filesystem inspection and modificationroutines.</p>\\n<p>All paths are matched case-insensitively, regardless of the case-sensitivity of the underlying filesystem. The supported character set is limited to only those characters supported by vfat filesystems (valid Windows characters). The usbplayer sample application is a good example of roFileSystem usage. USB devices with VFAT, NTFS, HFS, and HFS Plus filesystems are supported. The USB filesystems are currently mounted read only. </p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roFileSystem\\\")</code></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iffilesystem.md\\\" title=\\\"ifFileSystem\\\">ifFileSystem</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rofilesystemevent.md\\\" title=\\\"roFileSystemEvent\\\">roFileSystemEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rofloat.md":"{\n  \"content\": \"<h1 id=\\\"rofloat\\\">roFloat</h1>\\n<p>roFloat is the object equivalent for intrinsic type 'Float'.</p>\\n<p>This is useful in the following situations:</p>\\n<ul>\\n<li>If any object exposes the ifFloat interface, that object can be used in any expression that expects an intrinsic value.</li>\\n</ul>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iffloat.md\\\" title=\\\"ifFloat\\\">ifFloat</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rofont.md":"{\n  \"content\": \"<h1 id=\\\"rofont\\\">roFont</h1>\\n<p>roFont represents a particular font, from a font-family (eg. Arial), with a particular pixel size (e.g 20), and a particular boldness or italicness. </p>\\n<p>It is used in conjunction with <a href=\\\"/docs/references/brightscript/components/rofontregistry.md\\\" title=\\\"roFontRegistry\\\">roFontRegistry</a> to create and manage fonts. Font files are registered with roFontRegistry and then various methods in roFontRegistry can be used to create roFont objects.  Applications should not create roFonts with CreateObject() but should always use roFontRegistry to create them. roFont objects in turn can be used with <a href=\\\"/docs/references/brightscript/interfaces/ifdraw2d.md#drawtextrgba-as-integer-x-as-integer-y-as-integer-text-as-string-font-as-object-as-boolean\\\" title=\\\"ifDraw2D.DrawText\\\">ifDraw2D.DrawText</a> to draw text on the screen or into bitmaps.</p>\\n<p><strong>Example</strong></p>\\n<pre><code>screen = CreateObject(\\\"roScreen\\\")\\nwhite = &#x26;hFFFFFFFF\\nblue = &#x26;h0000FFFF\\nfont_registry = CreateObject(\\\"roFontRegistry\\\")\\nfont = font_registry.GetDefaultFont()\\n\\n' Draw white text in a blue rectangle\\ntext = \\\"Hello world\\\"\\nw = font.GetOneLineWidth(text, screen.GetWidth())\\nh = font.GetOneLineHeight()\\nx = 200\\ny = 100\\nborder = 8\\nscreen.DrawRect(x, y, w + 2*border, h + 2*border, blue)\\nscreen.DrawText(text, x+border, y+border, white, font)\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iffont.md\\\" title=\\\"ifFont\\\">ifFont</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rofontmetrics.md":"{\n  \"content\": \"<h1 id=\\\"rofontmetrics\\\">roFontMetrics</h1>\\n<blockquote>\\n<p>This class is deprecated. Developers should use <a href=\\\"/docs/references/brightscript/components/roFont.md\\\" title=\\\"roFont\\\">roFont</a> methods (GetOneLineHeight and GetOneLineWidth).</p>\\n</blockquote>\\n<p>The roFontMetrics object allows you to get display size information for a specific font returned by the roFontRegistry.Get() method.</p>\\n<p>In order to use this object, you must first initialize the roFontMetrics object with a font name that had been previously registered with the roFontRegistry, then the total rendered size of strings in that font can be returned by roFontMetrics.Size(). </p>\\n<p>This object is created with a string that represents the font to use in its size calculations:</p>\\n<p><code>CreateObject(\\\"roFontMetrics\\\", String font)</code></p>\\n<p><strong>Example: Simple use of roFontRegistry and roFontMetrics to render a string on the roImageCanvas</strong></p>\\n<pre><code>helloString = \\\"Hello ImageCanvas\\\"\\n\\nfontReg = CreateObject(\\\"roFontRegistry\\\")\\nfontReg.Register(\\\"pkg:/fonts/LCDMono.ttf\\\")\\nfont = fontReg.Get(\\\"LCDMono\\\",36,50,false) ' 36pt, 50 is normal\\n                                          ' weight, no italics\\n\\nfontMetrics = CreateObject(\\\"roFontMetrics\\\", font)\\nstringSize = fontMetrics.size(helloString)\\n\\ncanvasItem = { \\n    Text:helloString\\n    TextAttrs:{Color:\\\"#FFCCCCCC\\\", Font:font, \\n    HAlign:\\\"HCenter\\\",\\n    VAlign:\\\"VCenter\\\", Direction:\\\"LeftToRight\\\"}\\n    TargetRect:{x:390,y:357, w:stringSize.w,h:stringSize.h}\\n}\\n\\ncanvas = CreateObject(\\\"roImageCanvas\\\")\\nport = CreateObject(\\\"roMessagePort\\\")\\ncanvas.SetMessagePort(m.port)\\n'Set opaque background\\ncanvas.SetLayer(0, {Color:\\\"#FF000000\\\", CompositionMode:\\\"Source\\\"})\\ncanvas.SetRequireAllImagesToDraw(true)\\ncanvas.SetLayer(1, canvasItem)\\ncanvas.Show()\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iffontmetrics.md\\\" title=\\\"ifFontMetrics\\\">ifFontMetrics</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rofontregistry.md":"{\n  \"content\": \"<h1 id=\\\"rofontregistry\\\">roFontRegistry</h1>\\n<p>The roFontRegistry object allows you to create roFont objects, either using the default font or using fonts in TrueType or OpenType files packaged with your application.</p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roFontRegistry\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>reg = CreateObject(\\\"roFontRegistry\\\")\\nfont = reg.GetDefaultFont(30, false, false)\\nscreen = CreateObject(\\\"roScreen\\\")\\nscreen.DrawText(\\\"hello world\\\", 100, 100, &#x26;hFFFFFFFF, font)\\n</code></pre>\\n<p><strong>Example using a font file</strong></p>\\n<pre><code>reg.Register(\\\"pkg:/fonts/myfont.ttf\\\")\\nfont = reg.GetFont(\\\"MyFont\\\", 30, false, false)\\nscreen = CreateObject(\\\"roScreen\\\")\\nscreen.DrawText(\\\"hello world\\\", 100, 100, &#x26;hFFFFFFFF, font)\\n</code></pre>\\n<p>Font files can quickly get very large, so be conscious of the size of the font files you include with your application. You should be able to find very good font files that are 50k or less. Anything larger is probably too big. The customvideoplayer sample application is a good example of usage.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iffontregistry.md\\\" title=\\\"ifFontRegistry\\\">ifFontRegistry</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rofunction.md":"{\n  \"content\": \"<h1 id=\\\"rofunction\\\">roFunction</h1>\\n<p>roFunction is the object equivalent for intrinsic type Function.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iffunction.md\\\" title=\\\"ifFunction\\\">ifFunction</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rogridscreen.md":"{\n  \"content\": \"<h1 id=\\\"rogridscreen\\\">roGridScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Grid Screen provides a graphical display of poster art from multiple content categories from within a single screen.</p>\\n<p>Users can browse within a category list by scrolling horizonally and between category lists by scrolling vertically. There is an optional callout box in the lower right corner of the screen that can display details about the focused item without leaving the screen. Each item in the grid screen is represented by an image (aka poster), so any type of item that can be visually represented by an image can be displayed in the poster screen. It is used to show lists of data to users and common patterns include content categories, movies, podcasts, pictures, and search results.\\nThe initial release of roGridScreen only enabled the default list style, \\\"portrait\\\", using the following art sizes:</p>\\n<ul>\\n<li>Artwork sizes: SD=110x150; HD=210x270</li>\\n</ul>\\n<p>It also required grid posters to be .jpg files.</p>\\n<p>Later Roku OS versions added mixed aspect ratio grids, and the <a href=\\\"/docs/references/brightscript/interfaces/ifgridscreen.md\\\" title=\\\"ifGridScreen\\\">ifGridScreen</a> interface <a href=\\\"/docs/references/brightscript/interfaces/ifgridscreen.md#setlistposterstylesstyles-as-object-as-void\\\" title=\\\"SetListPosterStyles()\\\">SetListPosterStyles()</a> to set the aspect ratio of each row in the grid. If you want a mixed aspect ratio grid, you must call SetListPosterStyles() before you call <a href=\\\"/docs/references/brightscript/interfaces/ifgridscreen.md#setcontentlistrowindex-as-integer-contentlist-as-object-as-void\\\" title=\\\"SetContentList()\\\">SetContentList()</a>, to avoid possible distortion of the graphic images in the grid.</p>\\n<p><strong>Since Roku OS version 2.8</strong></p>\\n<p>File types of .png and .gif files are now supported, though they are converted internally to .jpg by the roGridScreen so they have a performance penalty.</p>\\n<p>In v2.8, there are now multiple grid styles that are specified in the SetGridStyle()method below. It's also worth going back and reviewing the appManager theme parameters in <a href=\\\"/docs/references/brightscript/components/roappmanager.md\\\" title=\\\"roAppManager\\\">roAppManager</a>, as v2.8 adds some new grid parameters. The border around the focused poster screen can be customized with the GridScreenFocusBorder images in png format. PNG files can have a transparent color value that you will need to allow the focused poster image to show through the border image. The corresponding offsets should be negative offsets that would be up and to the left of the top left corner of the poster image. The width of the borders should be the absolute values of the offsets and the rest of the image should be transparent inside. The GridScreenDescriptionImage is also positioned relative to the top left corner of the focused image. It can be positioned up and to the left with negative x and y offsets, below and to the right with positive offsets, or in the other corners with mixed signed x and y offsets. It's recommended that you include a \\\"callout\\\" tip pointing to the focused image in the GridScreenDescriptionImage.</p>\\n<p><strong>Diagram: roGridScreen</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roGridScreen.png\\\" alt=\\\"Diagram: roGridScreen\\\" title=\\\"roGridScreen\\\"></p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roGridScreen\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>Function Main()\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    grid = CreateObject(\\\"roGridScreen\\\")\\n    grid.SetMessagePort(port)\\n    rowTitles = CreateObject(\\\"roArray\\\", 10, true)\\n    for j = 0 to 10\\n        rowTitles.Push(\\\"[Row Title \\\" + j.toStr() + \\\" ] \\\")\\n    end for\\n    grid.SetupLists(rowTitles.Count())\\n    grid.SetListNames(rowTitles)\\n    for j = 0 to 10\\n    list = CreateObject(\\\"roArray\\\", 10, true)\\n    for i = 0 to 10\\n             o = CreateObject(\\\"roAssociativeArray\\\")\\n             o.ContentType = \\\"episode\\\"\\n             o.Title = \\\"[Title\\\" + i.toStr() + \\\"]\\\"\\n             o.ShortDescriptionLine1 = \\\"[ShortDescriptionLine1]\\\"\\n             o.ShortDescriptionLine2 = \\\"[ShortDescriptionLine2]\\\"\\n             o.Description = \\\"\\\"\\n             o.Description = \\\"[Description] \\\"\\n             o.Rating = \\\"NR\\\"\\n             o.StarRating = \\\"75\\\"\\n             o.ReleaseDate = \\\"[&#x3C;mm/dd/yyyy]\\\"\\n             o.Length = 5400\\n             o.Actors = []\\n             o.Actors.Push(\\\"[Actor1]\\\")\\n             o.Actors.Push(\\\"[Actor2]\\\")\\n             o.Actors.Push(\\\"[Actor3]\\\")\\n             o.Director = \\\"[Director]\\\"\\n             list.Push(o)\\n         end for\\n         grid.SetContentList(j, list)\\n     end for\\n     grid.Show()\\n     while true\\n         msg = wait(0, port)\\n         if type(msg) = \\\"roGridScreenEvent\\\" then\\n             if msg.isScreenClosed() then\\n                 return -1\\n             elseif msg.isListItemFocused()\\n                 print \\\"Focused msg: \\\";msg.GetMessage();\\\"row: \\\";msg.GetIndex();\\n                 print \\\" col: \\\";msg.GetData()\\n             elseif msg.isListItemSelected()\\n                 print \\\"Selected msg: \\\";msg.GetMessage();\\\"row: \\\";msg.GetIndex();\\n                 print \\\" col: \\\";msg.GetData()\\n             endif\\n         endif\\n     end while\\nEnd Function\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgridscreen.md\\\" title=\\\"ifGridScreen\\\">ifGridScreen</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rogridscreenevent.md\\\" title=\\\"roGridScreenEvent\\\">roGridScreenEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rohdmistatus.md":"{\n  \"content\": \"<h1 id=\\\"rohdmistatus\\\">roHdmiStatus</h1>\\n<p>The HDMI status component provides an interface to the current HDMI operational status.</p>\\n<p>This component allows you to query the status of the HDMI connection for the device through the ifHdmiStatus interface functions.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhdmistatus.md\\\" title=\\\"ifHdmiStatus\\\">ifHdmiStatus</a>                  </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>              </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rohmac.md":"{\n  \"content\": \"<h1 id=\\\"rohmac\\\">roHMAC</h1>\\n<p>The HMAC component provides an interface to the OpenSSL HMAC functions. These functions generate a Message Authentication Code (MAC) based on a key, in such a way that no one without the key could plausibly generate the MAC. HMAC uses a digest (hash) algorithm to generate the MAC.</p>\\n<blockquote>\\n<p>For additional information on the OpenSSL HMAC functions, please see: <a href=\\\"http://www.openssl.org/docs/crypto/hmac.html\\\">http://www.openssl.org/docs/crypto/hmac.html</a></p>\\n</blockquote>\\n<p><strong>Supported Digest Algorithms</strong></p>\\n<p>The supported digest algorithms are the same as those supported by <a href=\\\"/docs/references/brightscript/components/roevpdigest.md\\\" title=\\\"roEVPDigest\\\">roEVPDigest</a>.</p>\\n<p><strong>Example</strong></p>\\n<pre><code>hmac = CreateObject(\\\"roHMAC\\\")\\nsignature_key = CreateObject(\\\"roByteArray\\\")\\nsignature_key.fromAsciiString(getKey())\\nIf hmac.setup(\\\"sha1\\\", signature_key) = 0\\n    message = CreateObject(\\\"roByteArray\\\")\\n    message.fromAsciiString(getMessage())\\n    result = hmac.process(message)\\n    print result.toBase64String()\\nEnd If\\n\\n\\nhmac = CreateObject(\\\"roHMAC\\\")\\nsignature_key = CreateObject(\\\"roByteArray\\\")\\nsignature_key.fromAsciiString(getKey())\\nIf hmac.setup(\\\"sha1\\\", signature_key) = 0\\n    message1 = CreateObject(\\\"roByteArray\\\")\\n    message1.fromAsciiString(getMessage1())\\n    hmac.update(message1)\\n    message2 = CreateObject(\\\"roByteArray\\\")\\n    message2.fromAsciiString(getMessage2())\\n    hmac.update(message2)\\n    result = hmac.final()\\n    print result.toBase64String()\\nEnd If\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhmac.md\\\" title=\\\"ifHMAC\\\">ifHMAC</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rohttpagent.md":"{\n  \"content\": \"<h1 id=\\\"rohttpagent\\\">roHttpAgent</h1>\\n<p>All SceneGraph nodes can use the roHttpAgent component to support cookies, custom HTTP headers, and support secure HTTP file transfer protocols, such as passing certificates to the server as part of a URL transfer. An roHttpAgent component object is created by default for all SceneGraph nodes for this purpose. The roHttpAgent object supports the <a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a> interface used by many BrightScript components to allow secure HTTP file transfer protocols. Child nodes of a SceneGraph node automatically inherit the parent roHttpAgent object, unless a new roHttpAgent object is created, or an existing roHttpAgent is set for a child node. There are two roSGNode <a href=\\\"/docs/references/brightscript/interfaces/ifsgnodehttpagentaccess.md\\\" title=\\\"ifSGNodeHttpAgentAccess\\\">ifSGNodeHttpAgentAccess</a> interface methods that allow a specific roHttpAgent object to be selected and set for a specific SceneGraph node.</p>\\n<p>An roHttpAgent object is created automatically for all SceneGraph nodes, or can be created with no parameters:</p>\\n<p><code>CreateObject(\\\"roHttpAgent\\\")</code></p>\\n<blockquote>\\n<p>SceneGraph Audio and Video nodes always create a new roHttpAgent object and do not share it, and can use a different mechanism for HTTPS and cookie support, that involves setting certificates and cookies as Content Meta-Data attributes for the node ContentNode node.</p>\\n</blockquote>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roimagecanvas.md":"{\n  \"content\": \"<h1 id=\\\"roimagecanvas\\\">roImageCanvas</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The roImageCanvas component provides an interface to render graphic elements at specific spots on the screen.</p>\\n<p>Although it is not intended to be a full-fledged graphics component for high-performance gaming, it does provide a simple interface for building custom animations out of arrays of images displayed on the screen.</p>\\n<p>An item (graphical element) may be one of three types: image, text, or colored rectangle. The item type is determined by the <a href=\\\"/docs/developer-program/getting-started/architecture/content-metadata.md\\\" title=\\\"Content Meta-data\\\">Content Meta-data</a> fields set on the item.</p>\\n<h4 id=\\\"image\\\">Image</h4>\\n<p>If the URL attribute is set, the item is displayed as an image.</p>\\n<p><strong>Attributes (see <a href=\\\"/docs/developer-program/getting-started/architecture/content-metadata.md\\\" title=\\\"Content Meta-Data\\\">Content Meta-Data</a>):</strong></p>\\n<ul>\\n<li>URL</li>\\n<li>CompositionMode</li>\\n<li>SourceRect</li>\\n<li>TargetRect</li>\\n<li>TargetTranslation</li>\\n<li>TargetRotation</li>\\n</ul>\\n<h4 id=\\\"text\\\">Text</h4>\\n<p>If the Text attribute is set, the item is displayed as text.</p>\\n<p><strong>Attributes (see <a href=\\\"/docs/developer-program/getting-started/architecture/content-metadata.md\\\" title=\\\"Content Meta-Data\\\">Content Meta-Data</a>):</strong></p>\\n<ul>\\n<li>Text</li>\\n<li>TextAttrs { Color, Font, HAlign, VAlign, Direction }</li>\\n<li>TargetRect</li>\\n</ul>\\n<h4 id=\\\"rectangle\\\">Rectangle</h4>\\n<p>If the Color attribute is set, the item is displayed as a filled rectangle.</p>\\n<p><strong>Attributes (see <a href=\\\"/docs/developer-program/getting-started/architecture/content-metadata.md\\\" title=\\\"Content Meta-Data\\\">Content Meta-data</a>):</strong></p>\\n<ul>\\n<li>Color</li>\\n<li>TargetRect</li>\\n</ul>\\n<p><strong>Example: Displays two images and some text on the screen</strong></p>\\n<pre><code>Sub showImageCanvas()\\n    canvasItems = [\\n        { \\n            url:\\\"http://192.168.1.23/boardwalk.jpg\\\"\\n            TargetRect:{x:100,y:100,w:400,h:300}\\n        },\\n        {  \\n            url:\\\"http://192.168.1.23/walking.jpg\\\"\\n            TargetRect:{x:500,y:400,w:400,h:300}\\n        },\\n        { \\n            Text:\\\"Hello ImageCanvas\\\"\\n            TextAttrs:{Color:\\\"#FFCCCCCC\\\", Font:\\\"Medium\\\",\\n            HAlign:\\\"HCenter\\\", VAlign:\\\"VCenter\\\",\\n            Direction:\\\"LeftToRight\\\"}\\n            TargetRect:{x:390,y:357,w:500,h:60}\\n        }\\n    ]\\n\\n   canvas = CreateObject(\\\"roImageCanvas\\\")\\n   port = CreateObject(\\\"roMessagePort\\\")\\n   canvas.SetMessagePort(port)\\n   'Set opaque background\\n   canvas.SetLayer(0, {Color:\\\"#FF000000\\\", CompositionMode:\\\"Source\\\"})\\n   canvas.SetRequireAllImagesToDraw(true)\\n   canvas.SetLayer(1, canvasItems)\\n   canvas.Show()\\n   while(true)\\n       msg = wait(0,port)\\n       if type(msg) = \\\"roImageCanvasEvent\\\" then\\n           if (msg.isRemoteKeyPressed()) then\\n               i = msg.GetIndex()\\n               print \\\"Key Pressed - \\\" ; msg.GetIndex()\\n               if (i = 2) then\\n                   ' Up - Close the screen.\\n                   canvas.close()\\n               end if\\n           else if (msg.isScreenClosed()) then\\n               print \\\"Closed\\\"\\n               return\\n           end if\\n       end if\\n   end while\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifimagecanvas.md\\\" title=\\\"ifImageCanvas\\\">ifImageCanvas</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/roimagecanvasevent.md\\\" title=\\\"roImageCanvasEvent\\\">roImageCanvasEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roimagemetadata.md":"{\n  \"content\": \"<h1 id=\\\"roimagemetadata\\\">roImageMetadata</h1>\\n<p>The roImageMetadata component provides developers access to image file metadata included in many .jpg EXIF headers.</p>\\n<p>roImageMetadata currently only works with local file Urls. </p>\\n<p>This object is created without any arguments:</p>\\n<p><code>CreateObject(\\\"roImageMetadata\\\")</code></p>\\n<h4 id=\\\"exif-background\\\">EXIF Background</h4>\\n<p>Each EXIF tag represents one piece of metadata. Each tag is uniquely identified by a tag number and the IFD in which it was found. All the tags are grouped into a small set of IFDs (Image File Directory). The EXIF specification describes 5 IFDs:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Number</th>\\n<th>Name</th>\\n<th>Notes</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>0</td>\\n<td>image</td>\\n<td>Tags related to image structure and some additional basic information</td>\\n</tr>\\n<tr>\\n<td>1</td>\\n<td>thumbnail</td>\\n<td>Tags related to the thumbnail image structure</td>\\n</tr>\\n<tr>\\n<td>2</td>\\n<td>exif</td>\\n<td>Tags related to non-image structure data. I know this is an odd name. Usually stuff like ApertureValue that a digital camera would write</td>\\n</tr>\\n<tr>\\n<td>3</td>\\n<td>gps</td>\\n<td>Tags related to GPS</td>\\n</tr>\\n<tr>\\n<td>4</td>\\n<td>interoperability</td>\\n<td></td>\\n</tr>\\n</tbody>\\n</table>\\n<p>The associative array returned by GetRawExif() function on the roImageMetadata component is organized as a tree where the first level consists of the IFDs, the second level is the tag name, and the third (leaf) level is tag associative array. </p>\\n<p>Each tag associative array contains the following values:</p>\\n<table>\\n<thead>\\n<tr>\\n<th>Number</th>\\n<th>Name</th>\\n<th>Notes</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>Tag</td>\\n<td>Integer</td>\\n<td>The tag number</td>\\n</tr>\\n<tr>\\n<td>Value</td>\\n<td>String</td>\\n<td>This is a string representation of the data regardless of the underlying data type</td>\\n</tr>\\n</tbody>\\n</table>\\n<p>Tag values can be one of several types (string, bytes, rational, enum, etc.) We are using a that converts most values to a string. In the future or time permitting, we may add more values to the tag aa to give access to raw bytes. </p>\\n<p>The best way to illustrate how the EXIF data is accessed is through some concrete examples using the data in the reference section below. Assume that the associative array aa contains the results of the GetRawExif() function.</p>\\n<ul>\\n<li>To get the camera model: aa.image.model.value</li>\\n<li>To get the gps latitude: aa.gps.GPSLatitude.value</li>\\n</ul>\\n<h4 id=\\\"reference\\\">Reference</h4>\\n<p>For reference here are all the fields from an image taken from my camera (with the addition of GPS attributes I added using Picasa). </p>\\n<p>The format is IFD#, Tag#[Tag Name], Data Format, Value. The Value is a string representation of data. </p>\\n<pre><code>0, 272[ Model], ASCII,Canon PowerShot SD700 IS\\n0, 274[ Orientation], Short,top - left\\n0, 283[ YResolution], Rational,180.00\\n0, 296[ ResolutionUnit], Short,Inch\\n0, 305[ Software], ASCII,Picasa 3.0\\n0, 306[ DateTime], ASCII,2007:08:14 10:06:48\\n0, 531[ YCbCrPositioning], Short,centered\\n0, 282[ XResolution], Rational,72.00\\n1, 259[ Compression], Short,JPEG compression\\n1, 282[ XResolution], Rational,180.00\\n1, 283[ YResolution], Rational,180.00\\n1, 296[ ResolutionUnit], Short,Inch\\n2,33434[ ExposureTime], Rational,1/320 sec.\\n2,33437[ FNumber], Rational,f/2.8\\n2,36864[ ExifVersion], Undefined,Exif Version 2.2\\n2,36867[ DateTimeOriginal], ASCII,2007:08:14 10:06:48\\n2,36868[ DateTimeDigitized], ASCII,2007:08:14 10:06:48\\n2,37121[ ComponentsConfiguration], Undefined,Y Cb Cr -\\n2,37122[ CompressedBitsPerPixel], Rational,5.00\\n2,37377[ ShutterSpeedValue], SRational,8.31 EV (1/317 sec.)\\n2,37378[ ApertureValue], Rational,2.97 EV (f/2.8)\\n2,37380[ ExposureBiasValue], SRational,0.00 EV\\n2,37381[ MaxApertureValue], Rational,2.97 EV (f/2.8)\\n2,37383[ MeteringMode], Short,Pattern\\n2,37385[ Flash], Short,Flash did not fire, auto mode\\n2,37386[ FocalLength], Rational,5.8 mm\\n2,37500[ MakerNote], Undefined,1838 bytes undefined data\\n2,37510[ UserComment], Undefined,\\n2,40960[ FlashPixVersion], Undefined,FlashPix Version 1.0\\n2,40961[ ColorSpace], Short,sRGB\\n2,40962[ PixelXDimension], Short,2816\\n2,40963[ PixelYDimension], Short,2112\\n2,41486[ FocalPlaneXResolution], Rational,12515.56\\n2,41487[ FocalPlaneYResolution], Rational,12497.04\\n2,41488[ FocalPlaneResolutionUnit], Short,Inch\\n2,41495[ SensingMethod], Short,One-chip color area sensor\\n2,41728[ FileSource], Undefined,DSC\\n2,41985[ CustomRendered], Short,Normal process\\n2,41986[ ExposureMode], Short,Auto exposure\\n2,41987[ WhiteBalance], Short,Auto white balance\\n2,41988[ DigitalZoomRatio], Rational,1.00\\n2,41990[ SceneCaptureType], Short,Standard\\n2,42016[ ImageUniqueID], ASCII,ba6ad9a9d88ffd9576ea6155afa6c6ef\\n3, 0[ GPSVersionID], Byte,2.2.0.0\\n3, 1[ GPSLatitudeRef], ASCII,N\\n3, 2[ GPSLatitude], Rational,40.00, 12.00, 44.79\\n3, 3[ GPSLongitudeRef], ASCII,W\\n3, 4[ GPSLongitude], Rational,75.00, 37.00, 47.58\\n3, 5[ GPSAltitudeRef], Byte,Sea level\\n4, 1[ InteroperabilityIndex], ASCII,R98\\n4, 2[ InteroperabilityVersion], Undefined,0100\\n4, 4097[ RelatedImageWidth], Short,2816\\n4, 4098[ RelatedImageLength], Short,2112\\n</code></pre>\\n<p><strong>Example</strong></p>\\n<pre><code>REM printAA() is from generalUtils.brs in our sample apps\\nREM and used to print an associative Array\\nSub SaveExifImage(filename As String)\\n    meta = CreateObject(\\\"roImageMetadata\\\")\\n    meta.SetUrl(filename)\\n    print \\\"------------- GetRawExif() ----------------------\\\"\\n    allexif = meta.GetRawExif()\\n    printAA(allexif)\\n    print \\\"------------- GetMetadata() ---------------------\\\"\\n    simple = meta.GetMetadata()\\n    printAA(simple)\\n    print \\\"------------- GetRawExifTag() -------------------\\\"\\n    rawexiftag = meta.GetRawExifTag(2,36868)\\n    printAA(rawexiftag)\\n    print \\\"------------- GetThumbnail() --------------------\\\"\\n    thumbnail = meta.GetThumbnail()\\n    if (thumbnail &#x3C;> invalid) then\\n        if (thumbnail.bytes = invalid) then\\n            return\\n        end if\\n        imgtype = thumbnail.type\\n        image_ext=\\\"\\\"\\n        if (imgtype = \\\"image/jpeg\\\" or imgtype = \\\"jpg\\\") then\\n            image_ext = \\\"jpg\\\"\\n        else if (imgtype = \\\"image/png\\\" or imgtype = \\\"png\\\") then\\n            image_ext = \\\"png\\\"\\n        else\\n            image_ext = \\\"jpg\\\"\\n        end if\\n        tmp_img = \\\"tmp:/TmpExifImage\\\" + \\\".\\\" + image_ext\\n        if (tmp_img &#x3C;> invalid) then\\n            DeleteFile(tmp_img)\\n        end if\\n        thumbnail.bytes.Writefile(tmp_img)\\n    end if\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifimagemetadata.md\\\" title=\\\"ifImageMetadata\\\">ifImageMetadata</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roinput.md":"{\n  \"content\": \"<h1 id=\\\"roinput\\\">roInput</h1>\\n<p>An roInput object can be used to receive events sent from a network client using the External Control Protocol (ECP), as described in <a href=\\\"/docs/developer-program/debugging/external-control-api.md\\\" title=\\\"External Control API\\\">External Control API</a>.</p>\\n<blockquote>\\n<p>The <a href=\\\"/docs/developer-program/getting-started/architecture/channel-manifest.md#launch-requirement-attributes\\\">supports_input_launch manifest flag</a> must be set for channels to accept deep linking parameters when already running. This flag enables deep linking into content without relaunching the channel. See the <a href=\\\"https://github.com/rokudev/deep-Linking-samples\\\">Deep Linking sample channel</a> for how to use roInput to handle deep links into content while the channel is already running.</p>\\n</blockquote>\\n<p>Refer to <a href=\\\"/docs/developer-program/debugging/external-control-api.md#external-control-service-commands\\\" title=\\\"External Control Service Commands\\\">External Control Service Commands</a> for information about the ECP input command.</p>\\n<p>This object is created without any arguments:</p>\\n<p><code>CreateObject(\\\"roInput\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<p>The following prints information received from an external device in JSON format. If the external device sends the following input command:</p>\\n<pre><code>curl -d '' '&#x3C;roku_target_device>:8060/input?my_event=My%20Test&#x26;x=100&#x26;y=200&#x26;action=start'\\n</code></pre>\\n<p>The following will be printed:</p>\\n<pre><code>{\\\"action\\\":\\\"start\\\",\\\"my_event\\\":\\\"My Test\\\",\\\"x\\\":\\\"100\\\",\\\"y\\\":\\\"200\\\"}\\n</code></pre>\\n<p><strong>roInput Example</strong></p>\\n<pre><code>msgPort = CreateObject(\\\"roMessagePort\\\")\\n\\ninput = CreateObject(\\\"roInput\\\")\\ninput.SetMessagePort(msgPort)\\n\\nprint \\\"Waiting for messages...\\\"\\nwhile true\\n  msg = wait(0, msgPort)\\n  if type(msg) = \\\"roInputEvent\\\"\\n    if msg.IsInput()\\n      info = msg.GetInfo()\\n      print \\\"Received input: \\\"; FormatJSON(info)\\n    end if\\n  end if\\nend while\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifinput.md\\\" title=\\\"ifInput\\\">ifInput</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/roinputevent.md\\\" title=\\\"roInputEvent\\\">roInputEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roint.md":"{\n  \"content\": \"<h1 id=\\\"roint\\\">roInt</h1>\\n<p>roInput is the object equivalent for intrinsic type Integer.</p>\\n<p>This is useful in the following situations:</p>\\n<ul>\\n<li>When an object is needed, instead of an intrinsic value. For example, \\\"roList\\\" maintains a list of objects. If an Integer is added to roList, it will be automatically wrapped in an roInt by the language interpreter. When a function that expects a BrightScript Component as a parameter is passed an int, BrightScript automatically creates the equivalent BrightScript Component.</li>\\n<li>If any object exposes the ifInt interface, that object can be used in any expression that expects an intrinsic value. For example, in this way an roTouchEvent can be used as an integer whose value is the userid of the roTouchEvent.</li>\\n</ul>\\n<blockquote>\\n<p>If o is an roInt, then the following statements have the following effects</p>\\n<p>print o ' prints o.GetInt()</p>\\n<p>i%=o ' assigns the integer i% the value of o.GetInt()</p>\\n<p>k=o 'presumably k is dynamic typed, so it becomes another reference to the roInt o</p>\\n<p>o=5 'this is NOT the same as o.SetInt(5). Instead it releases o, and 'changes the type of o to Integer (o is dynamically typed). And assigns it to 5.</p>\\n</blockquote>\\n<p><strong>Example</strong></p>\\n<pre><code>BrightScript> o=CreateObject(\\\"roInt\\\")\\nBrightScript> o.SetInt(555)\\nBrightScript> print o\\n555\\nBrightScript> print o.GetInt()\\n555\\nBrightScript> print o-55\\n500\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifint.md\\\" title=\\\"ifInt\\\">ifInt</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifintops.md\\\" title=\\\"ifIntOps\\\">ifIntOps</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roinvalid.md":"{\n  \"content\": \"<h1 id=\\\"roinvalid\\\">roInvalid</h1>\\n<p>roInvalid is the object equivalent for intrinsic type 'Invalid'.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rokeyboardscreen.md":"{\n  \"content\": \"<h1 id=\\\"rokeyboardscreen\\\">roKeyboardScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Keyboard Screen is designed to allow the user to enter an alpha-numeric string for searching, username/password registration or other purposes.</p>\\n<p>This component is generally used as part of a sequence of screens and the results are displayed on the subsequent screen in the sequence. In the case of a search screen, results are displayed on the roPosterScreen and categories may be used to segregate TV and Movie results.</p>\\n<p><strong>Diagram: roKeyboardScreen</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roKeyboardScreenImage1.png\\\" alt=\\\"**Diagram: roKeyboardScreen**\\\" title=\\\"roKeyboardScreenImage1\\\"></p>\\n<p><strong>Example</strong></p>\\n<pre><code>Sub Main()\\n     screen = CreateObject(\\\"roKeyboardScreen\\\")\\n     port = CreateObject(\\\"roMessagePort\\\")\\n     screen.SetMessagePort(port)\\n     screen.SetTitle(\\\"Search Screen\\\")\\n     screen.SetText(\\\"default\\\")\\n     screen.SetDisplayText(\\\"enter text to search\\\")\\n     screen.SetMaxLength(8)\\n     screen.AddButton(1, \\\"finished\\\")\\n     screen.AddButton(2, \\\"back\\\")\\n     screen.Show()\\n\\n     while true\\n         msg = wait(0, screen.GetMessagePort())\\n         print \\\"message received\\\"\\n         if type(msg) = \\\"roKeyboardScreenEvent\\\"\\n             if msg.isScreenClosed()\\n                 return\\n             else if msg.isButtonPressed() then\\n                 print \\\"Evt:\\\"; msg.GetMessage ();\\\" idx:\\\"; msg.GetIndex()\\n                 if msg.GetIndex() = 1\\n                     searchText = screen.GetText()\\n                     print \\\"search text: \\\"; searchText\\n                     return\\n                 endif\\n             endif\\n         endif\\n     end while\\nEnd Sub\\n</code></pre>\\n<p><strong>Image: roKeyboardScreen example results</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roKeyboardScreenImage2.png\\\" alt=\\\"Image: roKeyboardScreen example results\\\" title=\\\"roKeyboardScreenImage2\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifkeyboardscreen.md\\\" title=\\\"ifKeyboardScreen\\\">ifKeyboardScreen</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rokeyboardscreenevent.md\\\" title=\\\"roKeyboardScreenEvent\\\">roKeyboardScreenEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rolist.md":"{\n  \"content\": \"<h1 id=\\\"rolist\\\">roList</h1>\\n<p>The list object implements the interfaces: ifList, ifArray, ifEnum and therefore can behave like an array that can dynamically add members. The array operator [ ] can be used to access any element in the ordered list.</p>\\n<p><strong>Example</strong></p>\\n<p>Implementation:</p>\\n<pre><code>list = CreateObject(\\\"roList\\\")\\nlist.AddTail(\\\"a\\\")\\nlist.AddTail(\\\"b\\\")\\nlist.AddTail(\\\"c\\\")\\nlist.AddTail(\\\"d\\\")\\nlist.ResetIndex()\\nx= list.GetIndex()\\nwhile x &#x3C;> invalid\\n    print x\\n    x = list.GetIndex()\\nend while\\n\\n\\nprint list[2]\\n</code></pre>\\n<p>Output:</p>\\n<pre><code>a\\nb\\nc\\nd\\nc \\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported Interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iflist.md\\\" title=\\\"ifList\\\">ifList</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarray.md\\\" title=\\\"ifArray\\\">ifArray</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarrayget.md\\\" title=\\\"ifArrayGet\\\">ifArrayGet</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifarrayset.md\\\" title=\\\"ifArraySet\\\">ifArraySet</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifenum.md\\\" title=\\\"ifEnum\\\">ifEnum</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iflisttoarray.md\\\" title=\\\"ifListToArray\\\">ifListToArray</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rolistscreen.md":"{\n  \"content\": \"<h1 id=\\\"rolistscreen\\\">roListScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The List Screen provides a graphical display of content in a vertical list within a single screen.</p>\\n<p>Users can browse the content by scrolling the text list vertically. The vertical list is displayed on the left side of the screen and the poster is displayed on the right side of the screen.  As the user scrolls through the content, the poster is updated with the poster art of the focused list item. There is an optional short description text below the poster that can display the description of the focused item and gets updated as the user scrolls the list.                           </p>\\n<p>The poster art uses the following art sizes:</p>\\n<pre><code>         Artwork sizes: SD=136x124; HD=250x250\\n</code></pre>\\n<p> roListScreen has a default dark highlight for the focused list item. The highlight can be customized by including a .png file with the following dimensions:</p>\\n<pre><code>         Highlight sizes: SD=304x38; HD=511x54\\n</code></pre>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roListScreen.png\\\" alt=\\\"List Screen Draft\\\" title=\\\"roListScreen\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iflistscreen.md\\\" title=\\\"ifListScreen\\\">ifListScreen</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rolistscreenevent.md\\\" title=\\\"roListScreenEvent\\\">roListScreenEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rolocalization.md":"{\n  \"content\": \"<h1 id=\\\"rolocalization\\\">roLocalization</h1>\\n<p>The roLocalization object provides functions to assist in localization. This object provides functions to assist in localization.</p>\\n<p>It is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roLocalization\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>loc = CreateObject(\\\"roLocalization\\\")\\nimage = loc.GetLocalizedAsset(\\\"images\\\", \\\"splash.png\\\")\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iflocalization.md\\\" title=\\\"ifLocalization\\\">ifLocalization</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rolonginteger.md":"{\n  \"content\": \"<h1 id=\\\"rolonginteger\\\">roLongInteger</h1>\\n<p>roLongInteger is the object name corresponding to the intrinsic LongInteger object.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iflongint.md\\\" title=\\\"ifLongInt\\\">ifLongInt</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/romessagedialog.md":"{\n  \"content\": \"<h1 id=\\\"romessagedialog\\\">roMessageDialog</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Message Dialog displays a formatted, multi-line text message to the user. The dialog may optionally be displayed with a busy animation to indicate progress on a long running operation. The dialog will automatically handle formatting of text and resize to fit. It may also display buttons to get user acknowledgment or a selection choice.</p>\\n<p>The following example shows an roMessageDialog with a single done button. When the title, text and button are added, the dialog automatically formats and resizes the dialog as needed for display when Show() is called.</p>\\n<p><strong>Diagram: roMessageDialog</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roMessageDialog.png\\\" alt=\\\"Diagram: roMessageDialog\\\" title=\\\"roMessageDialog\\\"></p>\\n<p><strong>Example</strong></p>\\n<p>The following code example creates a message dialog and displays it to the user. Note that dialogs are not full screen and that the previous screen is dimmed and displays in the background. When the user presses the message dialog button, the dialog is dismissed and the previous screen comes to the foreground. Since dialog.EnableBackButton(true) is also called, the message dialog is dismissed when the remote control's back button is pressed as well.  You can of course add additional buttons to your message dialogs that do things other than dismiss the dialog. You would simply need to implement button specific event handling code for these cases in the dlgMsg.isButtonPressed() code block.</p>\\n<pre><code>Function ShowMessageDialog() As Void\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    dialog = CreateObject(\\\"roMessageDialog\\\")\\n    dialog.SetMessagePort(port)\\n    dialog.SetTitle(\\\"[Message dialog title]\\\")\\n    dialog.SetText(\\\"[Message dialog text............]\\\")\\n\\n    dialog.AddButton(1, \\\"[button text]\\\")\\n    dialog.EnableBackButton(true)\\n    dialog.Show()\\n    While True\\n        dlgMsg = wait(0, dialog.GetMessagePort())\\n        If type(dlgMsg) = \\\"roMessageDialogEvent\\\"\\n            if dlgMsg.isButtonPressed()\\n                if dlgMsg.GetIndex() = 1\\n                    exit while\\n                end if\\n            else if dlgMsg.isScreenClosed()\\n                exit while\\n            end if\\n        end if\\n    end while\\nEnd Function\\n</code></pre>\\n<p><strong>Image: roMessageDialog example results</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roMessageDialogimage2.png\\\" alt=\\\"roMessageDialog example results\\\" title=\\\"roMessageDialogimage2\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifmessagedialog.md\\\" title=\\\"ifMessageDialog\\\">ifMessageDialog</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort \\\">ifGetMessagePort </a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/romessagedialogevent.md\\\" title=\\\"roMessageDialogEvent\\\">roMessageDialogEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/romessageport.md":"{\n  \"content\": \"<h1 id=\\\"romessageport\\\">roMessagePort</h1>\\n<p>A Message Port is the place messages (<a href=\\\"/docs/developer-program/core-concepts/event-loops.md\\\">events</a>) are sent. </p>\\n<p>When using BrightScript, you would not call these functions directly. Instead, use the \\\"Wait\\\" BrightScript statement.  </p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roMessagePort\\\")</code></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifmessageport.md\\\" title=\\\"ifMessagePort\\\">ifMessagePort</a> </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/romicrophone.md":"{\n  \"content\": \"<h1 id=\\\"romicrophone\\\">roMicrophone</h1>\\n<p>The roMicrophone API allows channel applications to receive audio data from the users microphone-supported remote control device or mobile phone. When a user initiates recording on their remote control device or mobile phone (via the Roku Mobile App) for the first time within the application, the application will request the users permission for the application to access the microphone by displaying a UI dialog box.</p>\\n<p>The application will only receive microphone access if the permission is granted by the user.</p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/microphone-access.jpg\\\" alt=\\\"microphone-access\\\" title=\\\"microphone-access\\\"></p>\\n<p>After the permission is granted, whenever a user activates the microphone, the application will display a notice informing the user that the microphone is currently being used by the application.</p>\\n<p>From the settings menu (Settings > Privacy > Microphone), the user can revoke microphone permissions from individual applications, at which time the particular application will not be able to access the microphone unless the user re-enables microphone permissions.</p>\\n<p>From the settings menu, the user may also:</p>\\n<ul>\\n<li>(a) enable universal microphone access permissions for all applications (thereby eliminating the need to request microphone permission on an application by application basis), and</li>\\n<li>(b) prohibit all applications from accessing the microphone.</li>\\n</ul>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/microphone-setting.jpg\\\" alt=\\\"microphone-setting\\\" title=\\\"microphone-setting\\\"></p>\\n<p>When integrating the roMicrophone API, you acknowledge and agree to the following:</p>\\n<ul>\\n<li>(i) that you will notify your users of your collection, use, and disclosure of any voice recordings or other derived data that you receive through the roMicrophone API;</li>\\n<li>(ii) you will not modify, circumvent, obscure, or otherwise diminish the notices provided by the roMicrophone API to users when they activate or enable microphone recording from their remote control device or mobile phone;</li>\\n<li>(iii) you will not collect any information from, or otherwise activate, the microphone on any remote control device or mobile phone using the roMicrophone API feature without receiving the requisite permissions from the user;</li>\\n<li>(iv) you have and will maintain a legally adequate privacy policy;</li>\\n<li>(v) you have and will maintain all necessary rights and consents from users to use the roMicrophone API features; and</li>\\n<li>(vi) your use of the roMicrophone API features will comply with all applicable laws, rules, and regulations.</li>\\n</ul>\\n<p>YOU FURTHER AGREE YOU WILL NOT USE THE roMicrophone API AND FEATURES IN CONNECTION WITH CONTENT OR CHANNELS DIRECTED TOWARD CHILDREN OR IN CONNECTION WITH USERS KNOWN TO BE CHILDREN. If Roku discovers or determines that you are using the roMicrophone API and features in connection with content or channels directed toward children or with users known to be children, Roku reserves the right to disable or otherwise limit your access to the roMicrophone API feature and related functionality.</p>\\n<p>YOU MAY NOT ENABLE THE roMicrophone API FEATURES IF YOU DO NOT AGREE TO ABOVE. PLEASE CONTACT ROKU FOR FURTHER INFORMATION.\\nImplementation</p>\\n<p>The application should display a focusable button or indicator in the UI that the user selects by pressing and holding the OK button. In response to the OK press event, the application can call:</p>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifmicrophone.md\\\" title=\\\"StartRecording\\\">StartRecording()</a> - to receive streamed audio data from the microphone asynchronously or</li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifmicrophone.md\\\" title=\\\"RecordToFile()\\\">RecordToFile()</a> - to have the audio data directly captured to a WAV format output file.</li>\\n</ul>\\n<blockquote>\\n<p>Roku OS will display a HUD to let the user initially consent to be recorded and to subsequently be informed when the microphone is being used. Recording is performed as long as the user holds down the OK button, or until a limit is reached or if an error should occur.</p>\\n</blockquote>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifmicrophone.md\\\" title=\\\"ifMicrophone\\\">ifMicrophone</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/romicrophoneevent.md\\\" title=\\\"roMicrophoneEvent\\\">roMicrophoneEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roonelinedialog.md":"{\n  \"content\": \"<h1 id=\\\"roonelinedialog\\\">roOneLineDialog</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The One Line Dialog is a special type of dialog optimized for single line text.</p>\\n<p>Unlike the message dialog (<a href=\\\"/docs/references/brightscript/components/roMessageDialog.md\\\" title=\\\"roMessageDialog\\\">roMessageDialog</a>) which displays formatted multi-line messages, roOneLineDialog displays a single line of text centered for the user.</p>\\n<p>This dialog is optimized for rendering of single-line text strings. It is generally used for displaying text to indicate that an operation is in progress. When the operation completes, the dialog is destroyed and the message dialog disappears.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifonelinedialog.md\\\" title=\\\"ifOneLineDialog\\\">ifOneLineDialog</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>   </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifGetMessagePort.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>   </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/roonelinedialogevent.md\\\" title=\\\"roOneLineDialogEvent\\\">roOneLineDialogEvent</a>  </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roparagraphscreen.md":"{\n  \"content\": \"<h1 id=\\\"roparagraphscreen\\\">roParagraphScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Paragraph Screen provides a way to display text and selection choices to the user.</p>\\n<p>This type of screen is frequently used for implementing wizard functionality to guide the user through a specific task. The caller may specify header text which is displayed at the top of the screen and one or more paragraphs of text on the screen. In addition, one or more buttons may be added to the screen to get user input or allow navigation. The screen is designed to automatically format the text, headings and buttons and create the photo-fit for them on screen. Some care must be taken to not provide too much text or clipping may occur.</p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roParagraphScreenImage1.png\\\" alt=\\\"roParagraphScreen image\\\" title=\\\"roParagraphScreenImage1\\\"></p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roParagraphScreen\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>Function ShowParagraphScreen() As Void\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    screen = CreateObject(\\\"roParagraphScreen\\\")\\n    screen.SetMessagePort(port)\\n    screen.SetTitle(\\\"[Screen Title]\\\")\\n    screen.AddHeaderText(\\\"[Header Text]\\\")\\n    screen.AddParagraph(\\\"[Paragraph text 1 - Text in the paragraph screen is justified to the right and left edges]\\\")\\n    screen.AddParagraph(\\\"[Paragraph text 2 - Multiple paragraphs may be added to the screen by simply making additional calls]\\\")\\n    screen.AddButton(1, \\\"[button text 1]\\\")\\n    screen.AddButton(2, \\\"[button text 2]\\\")\\n    screen.Show()\\n    while true\\n        msg = wait(0, screen.GetMessagePort())\\n        if type(msg) = \\\" roParagraphScreenEvent\\\"\\n            exit while\\n        endif\\n    end while\\nEnd Function\\n</code></pre>\\n<p><strong>Image: roParagraphScreen example results</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roParagraphScreenImage2.png\\\" alt=\\\"Image: roParagraphScreen example results\\\" title=\\\"roParagraphScreenImage2\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifparagraphscreen.md\\\" title=\\\"ifParagraphScreen\\\">ifParagraphScreen</a>        </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>       </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>      </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/roparagraphscreenevent.md\\\" title=\\\"roParagraphScreenEvento\\\">roParagraphScreenEvent</a>     </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/ropath.md":"{\n  \"content\": \"<h1 id=\\\"ropath\\\">roPath</h1>\\n<p>The roPath component provides developers an easy way to create valid file system paths. </p>\\n<p>The roPath component is a convenience class that implements <a href=\\\"/docs/references/brightscript/interfaces/ifstring.md\\\" title=\\\"ifString\\\">ifString</a> while providing additional validation and path inspection functionality. See <a href=\\\"docs/developer-program/getting-started/architecture/file-system.md\\\" title=\\\"File System\\\">File System</a> for more information about valid path names.</p>\\n<p>This object is created with a string that represents the initial path:</p>\\n<p><code>CreateObject(\\\"roPath\\\", \\\"ext1:/vid\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>path = CreateObject(\\\"roPath\\\", filename)\\nparts = path.Split()\\nif parts.phy = \\\"tmp:\\\" then print \\\"this is a temp file\\\"\\nif parts.extension = \\\".bmp\\\" then print \\\"this is a bitmap file\\\"\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifpath.md\\\" title=\\\"ifPath\\\">ifPath</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifstring.md\\\" title=\\\"ifString\\\">ifString</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/ropinentrydialog.md":"{\n  \"content\": \"<h1 id=\\\"ropinentrydialog\\\">roPinEntryDialog</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Pin Entry Dialog is designed to allow the user to enter a numeric PIN for purchasing content.</p>\\n<p>Users establish a PIN on the partner's website for purchasing transactions. The roPinEntryDialog allows the script to present the user with a pop-up, modal dialog for PIN entry and then the script can subsequently call the API's to conclude the purchase transaction. When the last digit is entered, focus jumps to the first button.</p>\\n<p><strong>Image: roPinEntryDialog sample</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roPinEntryDialog.png\\\" alt=\\\"roPinEntryDialog\\\" title=\\\"roPinEntryDialog\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifpinentrydialog.md\\\">ifPinEntryDialog</a>              </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\">ifSetMessagePort</a>              </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\">ifGetMessagePort</a>              </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/ropinentrydialogevent.md\\\">roPinEntryDialogEvent</a>              </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roposterscreen.md":"{\n  \"content\": \"<h1 id=\\\"roposterscreen\\\">roPosterScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roPosterScreen\\\")</code></p>\\n<p>The Poster Screen provides a graphical display of poster art for content selection or can be used as a submenu to provide hierarchical structure to the application.</p>\\n<p>In some cases, applications may wish to present a flat single-level list of titles in a queue, but the Poster Screen can also be used at multiple levels in the application to provide hierarchical browsing. It also provides an optional \\\"filter banner\\\" for displaying categories representing filtered subsets of the data or categorized groups.</p>\\n<p>Each item in the poster screen is represented by an image (aka poster), so any type of item that can be visually represented by an image can be displayed in the poster screen. It is used to show lists of data to users and common patterns include content categories, movies, podcasts, and search results.</p>\\n<p>Just below the overhang is the filter banner. It allows a method of easily selecting or filtering content based on categories. The categories are set by the developer during screen initialization, and the script is notified when a new category is highlighted or selected. Based on the event notification, the script can set the desired content in the view. The filter banner is optional.</p>\\n<p><strong>Diagram: roPosterScreen (flat-category)</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roPosterScreenImage1.png\\\" alt=\\\"Diagram: roPosterScreen (flat-category)\\\" title=\\\"roPosterScreenImage1\\\"></p>\\n<p>ShortDescriptionLine1 from the content metadata. Generally the category title.</p>\\n<p>ShortDescriptionLine2 from the content metadata. Generally a description for the category.</p>\\n<p><strong>Diagram: roPosterScreen (arced-landscape)</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roPosterScreenImage2.png\\\" alt=\\\"Diagram: roPosterScreen (arced-landscape\\\" title=\\\"roPosterScreenImage2\\\"></p>\\n<p><strong>Diagram: roPosterScreen (arced-portrait)</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roPosterScreenImage3.png\\\" alt=\\\"Diagram: roPosterScreen (arced-portrait)\\\" title=\\\"roPosterScreenImage3\\\"></p>\\n<p><strong>Diagram: roPosterScreen (flat-episodic)</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roPosterScreenImage4.png\\\" alt=\\\"Diagram: roPosterScreen (flat-episodic)\\\" title=\\\"roPosterScreenImage4\\\"></p>\\n<p>TV content is often displayed as a series of episodes within a season. The flat-episodic screen type provides a standard way to display episodic content, such as a TV series.</p>\\n<p>There is also a flat-episodic-16x9-episodic screen type to display episodic content with 16x9 images.</p>\\n<p>The paragraph text allows the user to view the synopsis for the currently selected episode. As the user scrolls right/left to select a new episode, the paragraph text and the short description lines are updated to reflect the description of the highlighted episode</p>\\n<p>In order to see poster art in the side posters instead of episode numbers, please ensure that the SDPosterUrl and HDPosterUrl are defined for the content and that episodeNumber is not defined for that content. EpisodeNumber overrides the poster URL.</p>\\n<p><strong>Example</strong></p>\\n<pre><code>Function Main()\\n     port = CreateObject(\\\"roMessagePort\\\")\\n     poster = CreateObject(\\\"roPosterScreen\\\")\\n     poster.SetBreadcrumbText(\\\"[location1]\\\", \\\"[location2]\\\")\\n     poster.SetMessagePort(port)\\n     list = CreateObject(\\\"roArray\\\", 10, true)\\n     For i = 0 To 10\\n         o = CreateObject(\\\"roAssociativeArray\\\")\\n         o.ContentType = \\\"episode\\\"\\n         o.Title = \\\"[Title]\\\"\\n         o.ShortDescriptionLine1 = \\\"[ShortDescriptionLine1]\\\"\\n         o.ShortDescriptionLine2 = \\\"[ShortDescriptionLine2]\\\"\\n         o.Description = \\\"\\\"\\n         o.Description = \\\"[Description] \\\"\\n         o.Rating = \\\"NR\\\"\\n         o.StarRating = \\\"75\\\"\\n         o.ReleaseDate = \\\"[&#x3C;mm/dd/yyyy]\\\"\\n         o.Length = 5400\\n         o.Categories = []\\n         o.Categories.Push(\\\"[Category1]\\\")\\n         o.Categories.Push(\\\"[Category2]\\\")\\n         o.Categories.Push(\\\"[Category3]\\\")\\n         o.Actors = []\\n         o.Actors.Push(\\\"[Actor1]\\\")\\n         o.Actors.Push(\\\"[Actor2]\\\")\\n         o.Actors.Push(\\\"[Actor3]\\\")\\n         o.Director = \\\"[Director]\\\"\\n         list.Push(o)\\n     End For\\n     poster.SetContentList(list)\\n     poster.Show()\\n\\n     While True\\n         msg = wait(0, port)\\n         If msg.isScreenClosed() Then\\n             return -1\\n         ElseIf msg.isListItemSelected()\\n             print \\\"msg: \\\";msg.GetMessage();\\\"idx: \\\";msg.GetIndex()\\n         End If\\n     End While\\n End Function\\n</code></pre>\\n<p>The following screen is displayed when this code is executed:  </p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roPosterScreenImage5.png\\\" alt=\\\"Image: roPosterScreen example result\\\" title=\\\"roPosterScreenImage5\\\"></p>\\n<p><strong>Image: roPosterScreen example result</strong></p>\\n<p>Note that in this example, we did not set valid values for SDPosterUrl or HDPoster URL, so no artwork is displayed. We have also elected not to display the filter banner and did not call the SetListNames API, so no filter banner is displayed. The screen is fully functional in other respects and responds to user input, scrolls left/right and receives events as the poster selection changes.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifposterscreen.md\\\" title=\\\"ifPosterScreen\\\">ifPosterScreen</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/roposterscreenevent.md\\\" title=\\\"roPosterScreenEvent\\\">roPosterScreenEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roprogramguide.md":"{\n  \"content\": \"<h1 id=\\\"roprogramguide\\\">roProgramGuide</h1>\\n<p>Represents Electronic Program Guide (EPG) information from the tuner. </p>\\n<p>Some Roku devices incorporate a tuner giving access to broadcast TV and radio received over an antenna or cable. In addition to the video and audio data from the tuner, the Roku Player receives electronic program guide (EPG) data about the currently-broadcasting program, and the next few programs to be broadcast. The roProgramGuide object provides access to that guide data.</p>\\n<p>This object can be created with no parameters:</p>\\n<p><code>createObject(\\\"roProgramGuide\\\")</code></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported Interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifprogramguide.md\\\">ifProgramGuide</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roregex.md":"{\n  \"content\": \"<h1 id=\\\"roregex\\\">roRegex</h1>\\n<p>The roRegex component provides the powerful regular expression processing of the PCRE library to Brightscript strings.</p>\\n<blockquote>\\n<p>Please see the PCRE documentation (<a href=\\\"http://www.pcre.org/\\\">http://www.pcre.org/</a>) for documentation on the PCRE library used for regular expression matching.  See the <a href=\\\"http://perldoc.perl.org/perlre.html\\\">perlre documentation</a> for complete documentation of the possible regular expressions this library can parse and match. In general, most Perl compatible regular expressions are supported.</p>\\n</blockquote>\\n<p>This object is created with a string that represents the matching-pattern and a string to indicate flags that modify the behavior of the matching operation(s):</p>\\n<p><code>CreateObject(\\\"roRegex\\\", \\\"[a-z]+\\\", \\\"i\\\")</code></p>\\n<p>The match string (\\\"[a-z]+\\\" in the example above, which matches all lowercase letters) can include most Perl compatible regular expressions documented in the PCRE documentation (<a href=\\\"http://www.pcre.org/\\\">http://www.pcre.org/</a>).</p>\\n<p>Any combination of the following behavior flags (\\\"i\\\" in the example above which modifies to match upper and lowercase letters) is supported:</p>\\n<ul>\\n<li>\\\"i\\\" Case insensitive match</li>\\n<li>\\\"m\\\" Multiline mode. The start of line \\\"^\\\" and end of line \\\"$\\\" constructs match immediately following or before any newline in the subject string as well as the very start and end of the string. Normally, just the start and end of the string would match.</li>\\n<li>\\\"s\\\" Sets dot-all mode that includes newline in the \\\".*\\\" regular expression. This modifier is equivalent to Perl's /s modifier.</li>\\n<li>\\\"x\\\" Sets extended mode that ignores whitespace characters except when escaped or inside a character class. Characters between an unescaped # outside a character a character class and the next newline character, inclusive, are also ignored. This modifier is equivalent to Perl's /x modifier.</li>\\n</ul>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifregex.md\\\" title=\\\"ifRegex\\\">ifRegex</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roregion.md":"{\n  \"content\": \"<h1 id=\\\"roregion\\\">roRegion</h1>\\n<p>The roRegion component is used to represent a subsection of a bitmap.</p>\\n<p>The region is specified with an x,y, width, and height as well as a time field for use with animated sprites and a wrap field which causes the region to wrap during scrolling. The roRegion is a common parameter used by the drawing functions of <a href=\\\"/docs/references/brightscript/components/robitmap.md\\\" title=\\\"roBitmap\\\">roBitmap</a>. Wrap and Time are used by <a href=\\\"/docs/references/brightscript/components/roCompositor.md\\\" title=\\\"roCompositor\\\">roCompositor</a>. roRegion is also used to specify a pretranslation (x,y) for the draw, rotate, and scale operation. The pretranslation is normally used to specify the center of the region. The scaling operation is controlled by the scalemode specified in the region. </p>\\n<p>This object is created with parameters to initialize the x,y coordinates, width, height. If time and wrap are desired, use the SetTime() and SetWrap().</p>\\n<p><code>CreateObject(\\\"roRegion\\\", Object bitmap, Integer x, Integer y,Integer width, Integer height)</code></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifregion.md\\\" title=\\\"ifRegion\\\">ifRegion</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roregistry.md":"{\n  \"content\": \"<h1 id=\\\"roregistry\\\">roRegistry</h1>\\n<p>The Registry is an area of non-volatile storage where a small number of persistent settings can be stored.</p>\\n<p>The Registry provides a means for an application to write and read small amounts of data such as settings, scores, etc. The data persists even if the user exits the application and even if the player is rebooted.  Registry data is removed only when the application explicitly removes it, the user uninstalls the application, which remove the registry for the application, or the user performs a factory reset, which removes the registry for all applications.</p>\\n<p>Access to the registry is available through the roRegistry object. This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roRegistry\\\")</code></p>\\n<p>There is a separate registry for each <a href=\\\"/docs/developer-program/publishing/packaging-channels.md#step-3-run-the-genkey-utility-to-create-a-signing-key\\\" title=\\\"developer ID\\\">developer ID</a>. This allows multiple applications to use the registry without being able to read or modify the registry from other applications. If desired, a single registry can be shared across multiple applications by using the same developer ID to package the applications. This is the conventional way that an \\\"application suite\\\" with shared preferences and other shared information should work.  Each registry is divided into sections which are specified by the developer for organization and grouping of attributes. Methods in ifRegistry are provided to list the sections in the registry and to provide access to the data in each section. </p>\\n<blockquote>\\n<p>The maximum size of each zlib-compressed application registry is <strong>16K bytes</strong>. Channels should minimize the amount of data stored in the registry and the frequency in which they update it.</p>\\n<p>Use the <strong>ifRegistry.GetSpaceAvailable()</strong> function to check the number of bytes available in the registry.</p>\\n</blockquote>\\n<p>The Registry also supports the use of a special transient registry section. A registry section named \\\"Transient\\\" can be used to store attributes that have the lifetime of a single boot. Within a specific boot session, these values will be persistent to the application and stored as any other registry value. Whenever the user reboots the Roku Streaming Player, all \\\"Transient\\\" registry sections are removed and the values no longer persist. This technique is useful for caching data to minimize network access, yet still ensuring that this data is always fresh after a system reboot.</p>\\n<p>The registry is encrypted, and updates are relatively performance intensive and should be used sparingly. Note that all writes to the registry are delayed, and not committed to non-volatile storage until ifRegistry.Flush() or ifRegistrySection.Flush() is explicitly called. The platform may choose opportune times to flush data on its own, but no application is technically correct unless it explicitly calls Flush() at appropriate times. Flushing the registry is a relatively time-consuming operation, so it should be done as infrequently as possible. The Registry data is stored in a fault tolerant manner by preserving a backup for each write which is automatically rolled-back in the event of a failure.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifregistry.md\\\" title=\\\"ifRegistry\\\">ifRegistry</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roregistrysection.md":"{\n  \"content\": \"<h1 id=\\\"roregistrysection\\\">roRegistrySection</h1>\\n<p>A Registry Section enables the organization of settings within the registry. Different registry sections may have their own keys with the same name. In other words, key names are scoped within the registry section to which they belong.</p>\\n<p>This object must be supplied with a \\\"section\\\" name on creation. If no such section exists, it will be created. Section names are case sensitive, so sections named \\\"Settings\\\" and \\\"settings\\\" are two different sections.</p>\\n<p><code>CreateObject(\\\"roRegistrySection\\\", section as String)</code></p>\\n<p><strong>Example: Get and set some user authentication in the registry</strong></p>\\n<pre><code>Function GetAuthData() As Dynamic\\n     sec = CreateObject(\\\"roRegistrySection\\\", \\\"Authentication\\\")\\n     if sec.Exists(\\\"UserRegistrationToken\\\")\\n         return sec.Read(\\\"UserRegistrationToken\\\")\\n     endif\\n     return invalid\\nEnd Function\\n\\nFunction SetAuthData(userToken As String) As Void\\n    sec = CreateObject(\\\"roRegistrySection\\\", \\\"Authentication\\\")\\n    sec.Write(\\\"UserRegistrationToken\\\", userToken)\\n    sec.Flush()\\nEnd Function\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifregistrysection.md\\\" title=\\\"ifRegistrySection\\\">ifRegistrySection</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rorsa.md":"{\n  \"content\": \"<h1 id=\\\"rorsa\\\">roRSA</h1>\\n<p>The RSA component provides an interface to the OpenSSL RSA library of signing algorithms.</p>\\n<p>This component can be used to sign/verify using RSA.</p>\\n<p>Typically, you would use the roEVPDigest component to create a message digest, then use roRSA to sign it.</p>\\n<p><strong>Example: RSA signing using SHA1</strong></p>\\n<pre><code>ba = CreateObject(\\\"roByteArray\\\")\\n\\n' ...populate bytearray...\\n\\ndigest = CreateObject(\\\"roEVPDigest\\\")\\ndigest.Setup(\\\"sha1\\\")\\nhashString = digest.Process(ba)\\nhashBA = CreateObject(\\\"roByteArray\\\")\\nhashBA.FromHexString(hashString)\\nrsa = CreateObject(\\\"roRSA\\\")\\n\\n' ... save private key to tmp:/privateKey.txt\\n\\nrsa.SetPrivateKey(\\\"tmp:/privateKey.txt\\\")\\nrsa.SetDigestAlgorithm(\\\"sha1\\\")\\nsignature = rsa.Sign(hashBA)\\n</code></pre>\\n<p><strong>Example: RSA verification using SHA1</strong></p>\\n<pre><code>rsa = CreateObject(\\\"roRSA\\\")\\nrsa.SetPublicKey(:tmp:/publicKey.txt\\\")\\nrsa.SetDigestAlgorithm(\\\"sha1\\\")\\n\\n' see hashBA and signature from above example\\n\\nresult = rsa.Verify(hashBA, signature)\\nif (result = 1)\\n    print \\\"Verified\\\"\\nelse\\n    print \\\"Not verified, result = \\\" ; result\\nend if\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifrsa.md\\\" title=\\\"ifRSA\\\">ifRSA</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roscreen.md":"{\n  \"content\": \"<h1 id=\\\"roscreen\\\">roScreen</h1>\\n<p>The roScreen component provides a full screen drawing surface that can be stacked and that you can receive input events from.</p>\\n<p>You will need at least one roScreen component in your 2D game application to draw on and get events from. The origin (0,0) is the top left corner of the screen. The pixels are always RGBA 32 bits. Multiple roScreen components stack, and like other screen components only the top screen is viewable and gets events. An roScreen that is not the top most screen can still be drawn to. </p>\\n<blockquote>\\n<p>Once an roScreen is created, the display stack enters \\\"Game Mode\\\", and other screen components cannot be used. Screensavers will also be disabled and will appear as a black screen in its place. Other screen components cannot be intermixed with roScreens as the roScreen display stack is maintained independently from the main screen component display stack. When the final roScreen component is closed, other screen components can be used again.</p>\\n</blockquote>\\n<p>When the roScreen constructor is called, an optional double buffer flag, and an optional resolution can be passed. If the screen is double buffered, two buffers are fully allocated when CreateObject() succeeds. If the screen is single buffered only one buffer is allocated and the \\\"front\\\" and \\\"back\\\" buffers in method descriptions below are the same buffer. When a screen is created with a different resolution than the output display, it is scaled automatically to the output display resolution. </p>\\n<p>To maintain proper aspect ratio, and take care of the different pixel aspect ratio in HD vs SD; there is a fixed set of bitmap resolutions that are allowed to be created for screens:</p>\\n<p><strong>HD mode screensizes</strong></p>\\n<ul>\\n<li>1280x720PAR=1:1 (default for HD)</li>\\n<li>854x480 PAR=1:1 useful for higher performance HD games, also for 640x480 games</li>\\n<li>940x480 PAR=1.1:1 used for displaying a RokuSD (720x480) games</li>\\n</ul>\\n<p><strong>SD mode screensizes</strong></p>\\n<ul>\\n<li>720x480 PAR=1.1:1 (default for SD)</li>\\n<li>640x480 PAR=1:1 (used for 640x480 games)</li>\\n<li>854x626 PAR=1:1 (used for 854x480 HD games)</li>\\n</ul>\\n<p>The screen dimensions correspond to the drawable area that applications see. The dimensions were chosen so that applications do not need to compensate for screen aspect ratio or pixel aspect ratio. </p>\\n<p>It's likely that when porting games from other platforms, the active game area may be smaller and correspond to more traditional dimensions. In this case, the application can supply letterbox or pillarbox artwork and use an <a href=\\\"/docs/references/brightscript/components/roregion.md\\\" title=\\\"roRegion\\\">roRegion</a> to define the active area. The roRegion will translate and clip graphics to the proper area for the game. Similarly, roRegions are used to describe the left and right pillars for an SD game in HD mode, or the upper and lower letterbox regions for an HD game in SD mode. </p>\\n<p>Games that require more performance should use smaller dimensions. Games should run in HD and SD mode. The screensizes HD 854x480 paired with SD 854x626 and HD 940x480 paired with SD 720x480 were designed for this purpose.</p>\\n<p>The game creates a single active game roRegion to do all graphics operations in. roRegions for pillar or letter boxes are used to fill the rest of the screen area depending on if the app is in HD or SD mode. Please refer to the dfSetupDisplayRegions() function in <a href=\\\"/docs/references/brightscript/language/component-architecture.md#v30bslcorebrs\\\" title=\\\"v30/bslDefender.brs\\\">v30/bslDefender.brs</a> for help in setting up the drawable regions in screen scaling. </p>\\n<p>There are some useful rules of thumb to be aware of to get the best performance when rendering your games:</p>\\n<ul>\\n<li>Alpha enabled regions are expensive to render</li>\\n</ul>\\n<p>It is a requirement that the destination be alpha enabled in order for non-rectangular sprites to be properly rendered with transparency. However the sprite used for a background would typically have all pixels be fully nontransparent. Since alpha blending is expensive, a quick way to blit the background in this scenario is to first disable alpha on the screen, manually draw the background, and then enable alpha for the screen before drawing the rest of the sprites.</p>\\n<ul>\\n<li>Use smaller resolution images wherever possible. Scaling a large image down at run time is expensive with no benefit to the user</li>\\n<li>Rendering text with DrawText() is expensive</li>\\n</ul>\\n<p>Fortunately, many of these calls are redundant and can be eliminated. The static text for a particular level can be drawn on the background once and this newly created background can be used for refreshing the screen. This will eliminate almost all text redraws. </p>\\n<p>A screen can be created with one of three constructors. If it is created with no parameters, the screen will be single buffered, and its output resolution will match the current display resolution (if the current resolution is specified in the manifest file ui_resolutions entry, otherwise the size will be 720p).</p>\\n<p><code>CreateObject(\\\"roScreen\\\")</code></p>\\n<p>If a single parameter is passed, it is a Boolean that indicates if the screen is double buffered or not. See SwapBuffers():</p>\\n<p><code>CreateObject(\\\"roScreen\\\", true) ' double buffered screen</code></p>\\n<p>If four parameters are passed, the last two specify the screen's resolution. The dimensions must be one of the screen sizes specified above:</p>\\n<p><code>CreateObject(\\\"roScreen\\\", true, 720, 480) ' db &#x26; SD res</code></p>\\n<p><strong>Example: Display an image</strong></p>\\n<pre><code>Screen=CreateObject(\\\"roScreen\\\")\\ndfDrawImage(screen, \\\"myphoto.jpg\\\",0,0)\\nScreen.Finish()\\n</code></pre>\\n<p><strong>Example: Alpha blending</strong></p>\\n<pre><code>white=&#x26;hFFFFFFFF\\nscreen0=CreateObject(\\\"roScreen\\\")\\nscreen0.SetAlphaEnable(true)\\nscreen0.Clear(white)\\nscreen0.DrawRect(100,100, screen0.GetWidth()-200, screen0.GetHeight()-200, &#x26;h80)\\n' &#x26;h80 is black with a 50% alpha mix (RGBA)\\nscreen0.finish()\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifscreen.md\\\" title=\\\"ifScreen\\\">ifScreen</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifdraw2d.md\\\" title=\\\"ifDraw2D\\\">ifDraw2D</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rouniversalcontrolevent.md\\\" title=\\\"roUniversalControlEvent\\\">roUniversalControlEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rosearchhistory.md":"{\n  \"content\": \"<h1 id=\\\"rosearchhistory\\\">roSearchHistory</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Search History object implements the system wide storage of search terms for use in implementing the roSearchScreen.</p>\\n<p>As the user searches for content, recent searches are placed into the search history. This allows the user to easily re-execute these commands later without typing on the keyboard. The initial list of recent searches is displayed on the roSearchScreen to assist the user in finding content to watch. This history is used system wide, so that the user can find references to their search in multiple types of content. </p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roSearchHistory\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>history = CreateObject(\\\"roSearchHistory\\\")\\nlist = history.GetAsArray()\\nprint \\\"There are \\\"; list.Count(); \\\" items in the history\\\"\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsearchhistory.md\\\" title=\\\"ifSearchHistory\\\">ifSearchHistory</a>            </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rosearchscreen.md":"{\n  \"content\": \"<h1 id=\\\"rosearchscreen\\\">roSearchScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Search Screen provides a standard way to allow users to enter text for searching.</p>\\n<p>This screen features a simplified keyboard (a-z, 0-9) designed to provide just the keys necessary to perform case-insensitive searches without punctuation.</p>\\n<p>Ideally, the user would enter a search string and the backend service would perform that query in a case-insensitive manner ignoring special characters like punctuation. The script is notified as each key is pressed so that a progress disclosure search can be performed if supported by the back-end service. In addition, the script can control the text displayed on the screen and will receive events when the text entry is complete.</p>\\n<p>In addition to entering search strings, this screen features a list that can be used to display search results or show the most recent searches. It's desirable for the screen to maintain a list of recent searches for the user to allow them to easily repeat a recent query without typing. In some implementations, it may be desirable to use this list to show a progressive set of results after each character while the user is typing.</p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roSearchScreen\\\")</code></p>\\n<p><strong>Example</strong></p>\\n<pre><code>REM ******************************************************\\nREM Main routine - example of search screen usage\\nREM ******************************************************\\nSub Main()\\n    print \\\"start\\\"\\n    'toggle the search suggestions vs. search history behavior\\n    'this allow you to generate both versions of the example below\\n    displayHistory = false\\n    history = CreateObject(\\\"roArray\\\", 1, true)\\n    'prepopulate the search history with sample results\\n    history.Push(\\\"seinfeld\\\")\\n    history.Push(\\\"fraiser\\\")\\n    history.Push(\\\"cheers\\\")\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    screen = CreateObject(\\\"roSearchScreen\\\")\\n    'commenting out SetBreadcrumbText() hides breadcrumb on screen\\n    screen.SetBreadcrumbText(\\\"\\\", \\\"search\\\")\\n    screen.SetMessagePort(port)\\n    if displayHistory\\n        screen.SetSearchTermHeaderText(\\\"Recent Searches:\\\")\\n        screen.SetSearchButtonText(\\\"search\\\")\\n        screen.SetClearButtonText(\\\"clear history\\\")\\n        screen.SetClearButtonEnabled(true) 'defaults to true\\n        screen.SetSearchTerms(history)\\n    else\\n        screen.SetSearchTermHeaderText(\\\"Suggestions:\\\")\\n        screen.SetSearchButtonText(\\\"search\\\")\\n        screen.SetClearButtonEnabled(false)\\n    endif\\n    print \\\"Doing show screen...\\\"\\n    screen.Show()\\n    print \\\"Waiting for a message from the screen...\\\"\\n    ' search screen main event loop\\n    done = false\\n    while done = false\\n        msg = wait(0, screen.GetMessagePort())\\n        if type(msg) = \\\"roSearchScreenEvent\\\"\\n            if msg.isScreenClosed()\\n                print \\\"screen closed\\\"\\n                done = true\\n            else if msg.isCleared()\\n                print \\\"search terms cleared\\\"\\n                history.Clear()\\n            else if msg.isPartialResult()\\n                print \\\"partial search: \\\"; msg.GetMessage()\\n                if not displayHistory\\n                    screen.SetSearchTerms(GenerateSearchSuggestions(msg.GetMessage()))\\n                endif\\n            else if msg.isFullResult()\\n                print \\\"full search: \\\"; msg.GetMessage()\\n                history.Push(msg.GetMessage())\\n                if displayHistory\\n                    screen.AddSearchTerm(msg.GetMessage())\\n                end if\\n                'uncomment to exit the screen after a full search result:\\n                'done = true\\n            else\\n                print \\\"Unknown event: \\\"; msg.GetType(); \\\" msg: \\\"; msg.GetMessage()\\n            endif\\n        endif\\n    endwhile\\n    print \\\"Exiting...\\\"\\nEnd Sub\\n\\nFunction GenerateSearchSuggestions(partSearchText As String) As Object\\n    availableContent = [\\n        \\\"ghost in the shell\\\"\\n        \\\"parasite dolls\\\"\\n        \\\"final fantasy\\\"\\n        \\\"ninja scroll\\\"\\n        \\\"space ghost\\\"\\n        \\\"hellboy\\\"\\n        \\\"star wars\\\"\\n        \\\"terminator\\\"\\n        \\\"house of cards\\\"\\n        \\\"dexter\\\"\\n        ]\\n    suggestions = []\\n    if partSearchText &#x3C;> \\\"\\\"\\n        partSearchText = LCase(partSearchText)\\n        for each available in availableContent\\n            if available.Instr(partSearchText) >= 0\\n                suggestions.Push(available)\\n            end if\\n        end for\\n    end if\\n    return suggestions\\nEnd Function\\n</code></pre>\\n<p><strong>Image: roSearchScreen example results (search suggestions)</strong></p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/roSearchScreen.png\\\" alt=\\\"Image: roSearchScreen example results (search suggestions)\\\" title=\\\"roSearchScreen\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsearchscreen.md\\\" title=\\\"ifSearchScreen\\\">ifSearchScreen</a>                </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>              </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n</ul>\\n<blockquote>\\n<p>Some Roku OS versions may implement ifSearchScreen as ifRoSearchScreen.</p>\\n</blockquote>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rosearchscreenevent.md\\\" title=\\\"roSearchScreenEvent\\\">roSearchScreenEvent</a>             </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rosgnode.md":"{\n  \"content\": \"<h1 id=\\\"rosgnode\\\">roSGNode</h1>\\n<p>The roSGNode object is the BrightScript equivalent of SceneGraph XML\\nfile node creation. To create an roSGNode object for a specific node\\nclass, call:</p>\\n<p><code>CreateObject(\\\"roSGNode\\\", \\\"nodetype\\\")</code></p>\\n<p>Where nodetype is a string specifying the node class to be created.\\nFor example, the following creates an object of the SceneGraph\\nPoster node class:</p>\\n<p><code>CreateObject(\\\"roSGNode\\\", \\\"Poster\\\")</code></p>\\n<p>Reference information on all SceneGraph node classes can be found in\\n<a href=\\\"/docs/references/scenegraph/abstract-nodes/node.md\\\">SceneGraph API\\nReference</a>.</p>\\n<p>Prior to creating an roSGScreen object and calling its <code>show()</code>\\nfunction, creating roSGNode objects and using their interfaces is\\nnot guaranteed to work correctly. If you need to create some\\nroSGNode objects and/or use roSGNode interfaces prior to calling\\nan roSGScreen object <code>show()</code> function, you can use an\\nroSGScreen object <code>createScene()</code> function to create an instance of\\na SceneGraph XML component that does any required setup and\\ninitialization prior to the roSGScreen object being displayed.</p>\\n<p>In addition, roSGNode implements the ifAssociativeArray interface as a wrapper for ifSGNodeFIeld so that the convenient node.field notation may be using for setting, getting, and observing fields.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported Interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifassociativearray.md\\\">ifAssociativeArray</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsgnodechildren.md\\\">ifSGNodeChildren</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsgnodefield.md\\\">ifSGNodeField</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsgnodedict.md\\\">ifSGNodeDict</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsgnodefocus.md\\\">ifSGNodeFocus</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsgnodeboundingrect.md\\\">ifSGNodeBoundingRect</a></li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsgnodehttpagentaccess.md\\\">ifSGNodeHttpAgentAccess</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported Events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rosgnodeevent.md\\\">roSGNodeEvent</a></li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rosgscreen.md":"{\n  \"content\": \"<h1 id=\\\"rosgscreen\\\">roSGScreen</h1>\\n<p>The roSGScreen object is a SceneGraph canvas that displays the\\ncontents of a SceneGraph Scene node instance. The object is created\\nby calling:</p>\\n<p><code>CreateObject(\\\"roSGScreen\\\")</code></p>\\n<p><code>CreateScene()</code> takes one argument, the name of the scene component.  A\\nchannel will typically extend Scene to define its own channel specific\\nScene type (such as MyScene, etc.)  This Scene component name is passed\\nto <code>CreateScene().</code></p>\\n<p><strong>roSGScreen typical usage example</strong></p>\\n<pre><code>screen = CreateObject(\\\"roSGScreen\\\")\\nscene  = screen.CreateScene(\\\"Scene\\\")\\nscreen.show()\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsgscreen.md\\\" title=\\\"ifSgScreen\\\">ifSgScreen</a></li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rosgscreenevent.md\\\" title=\\\"roSGScreenEvent\\\">roSGScreenEvent</a>             </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roslideshow.md":"{\n  \"content\": \"<h1 id=\\\"roslideshow\\\">roSlideShow</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Slide Show screen provides the ability to setup a photo slide show to playback a series of images.</p>\\n<p>Images may be jpg, png or gif files. The developer can control the sequencing and timing of the slideshow. The object is designed to accept an array of <a href=\\\"/docs/developer-program/getting-started/architecture/content-metadata.md\\\" title=\\\"Content Meta-Data\\\">Content Meta-Data</a> objects, describing the images and providing url's for accessing each image. TextOverlayUL, TextOverlayUR, and TextOverlayBody are content meta-data properties used to display a text overlay.  </p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roSlideShow\\\")</code></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifslideshow.md\\\" title=\\\"ifSlideShow\\\">ifSlideShow</a>            </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a>             </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/roslideshowevent.md\\\" title=\\\"roSlideShowEvent\\\">roSlideShowEvent</a> </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rosocketaddress.md":"{\n  \"content\": \"<h1 id=\\\"rosocketaddress\\\">roSocketAddress</h1>\\n<p>The roSocketAddress is used by the roStreamSocket and roDataGramSocket components for TCP and UDP traffic respectively.</p>\\n<p>This object is created without any arguments:</p>\\n<p><code>CreateObject(\\\"roSocketAddress\\\")</code></p>\\n<p>Methods in <a href=\\\"/docs/references/brightscript/interfaces/ifsocketaddress.md\\\" title=\\\"ifSocketAddress\\\">ifSocketAddress</a> are used to assign an IP address to the object. roSocketAddress currently supports only IPV4 addresses.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketaddress.md\\\" title=\\\"ifSocketAddress\\\">ifSocketAddress</a>            </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rospringboardscreen.md":"{\n  \"content\": \"<h1 id=\\\"rospringboardscreen\\\">roSpringboardScreen</h1>\\n<p>The Springboard Screen shows detailed information about an individual piece of content and provides options for actions that may be taken on that content.</p>\\n<p>The detailed description of the content is displayed with poster art for the title. Artwork may be displayed portrait or landscape orientation depending on the ContentType set in the <a href=\\\"/docs/developer-program/getting-started/architecture/content-metadata.md\\\" title=\\\"Content Meta-Data\\\">Content Meta-Data</a>.</p>\\n<p>The caller may add one or more buttons to the screen with actions such as Play, Resume, Purchase or More Info. The script is notified via an event when a button is selected and it is the responsibility of the script writer to handle that event as desired and perform the requested action.</p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/worddav3570180012b8208f098d035b989f8fa8.png\\\" alt=\\\"worddav-button-actions\\\" title=\\\"worddav3570180012b8208f098d035b989f8fa8\\\"></p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roSpringboardScreen\\\")</code></p>\\n<ul>\\n<li>\\n<p>Orientation for artwork is based on ContentType setting and may be portrait or landscape.</p>\\n</li>\\n<li>\\n<p>The audio springboard is capable of adding a progress bar.</p>\\n</li>\\n<li>\\n<p>If the ContentType is audio, the album art dimensions are:</p>\\n</li>\\n</ul>\\n<pre><code>    SD: 124 x 112\\n    HD: 188 x 188\\n</code></pre>\\n<ul>\\n<li>If the ContentType is episode, the album art dimensions are:</li>\\n</ul>\\n<pre><code>    SD: 180 x 122\\n    HD: 264 x 198\\n</code></pre>\\n<ul>\\n<li>If the ContentType is any other value, the album art dimensions are:</li>\\n</ul>\\n<pre><code>    SD: 112 x 142\\n    HD: 148 x 212\\n</code></pre>\\n<ul>\\n<li>\\n<p>Up to 5 user-defined buttons may be displayed. Buttons are displayed in the order they are added and always appear in a fixed region of the screen</p>\\n</li>\\n<li>\\n<p>The description text will be formatted and justified (right and left edges) to fit between the margins. When the maximum length is reached, the text will be clipped and terminated with an ellipsis. The font is variable pitch, so the maximum number of characters is dependent on the text. The spacing is approximately 85 characters per line x 4 lines = 340 characters. The fonts and character spacing for HD and SD are similar, and display approximately the same number of characters, but the relationship is not exactly 1:1.</p>\\n</li>\\n<li>\\n<p>The star rating can show either community StarRating (red) or UserStarRating (yellow). If both values are set, the control will display the UserStarRating. If ratings are not desired, it can be removed by calling SetStaticRatingEnabled(false), providing more space to display actor names.</p>\\n</li>\\n<li>\\n<p>The Length attribute will display a formatted string or show length. If the value is zero, this field will display 0m, if the attribute is not set/missing then this field will not be displayed.</p>\\n</li>\\n</ul>\\n<p><strong>Example</strong></p>\\n<p>The following example shows the process of creating an roSpringboardScreen, setting up the content meta-data, showing the screen and waiting for an event. This example is simplified for clarity and it's assumed the real-world applications will use techniques like getting data from web services using roUrlTransfer.</p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/springboard-audio.png\\\" alt=\\\"springboard-audio\\\" title=\\\"springboard-audio\\\"></p>\\n<pre><code>Function Main()\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    springBoard = CreateObject(\\\"roSpringboardScreen\\\")\\n    springBoard.SetBreadcrumbText(\\\"[location 1]\\\", \\\"[location2]\\\")\\n    springBoard.SetMessagePort(port)\\n    o = CreateObject(\\\"roAssociativeArray\\\")\\n    o.ContentType = \\\"episode\\\"\\n    o.Title = \\\"[Title]\\\"\\n    o.ShortDescriptionLine1 = \\\"[ShortDescriptionLine1]\\\"\\n    o.ShortDescriptionLine2 = \\\"[ShortDescriptionLine2]\\\"\\n    o.Description = \\\"\\\"\\n    For i = 1 To 15\\n        o.Description = o.Description + \\\"[Description] \\\"\\n    End For\\n    o.SDPosterUrl = \\\"\\\"\\n    o.HDPosterUrl = \\\"\\\"\\n    o.Rating = \\\"NR\\\"\\n    o.StarRating = \\\"75\\\"\\n    o.ReleaseDate = \\\"[mm/dd/yyyy]\\\"\\n    o.Length = 5400\\n    o.Categories = CreateObject(\\\"roArray\\\", 10, true)\\n    o.Categories.Push(\\\"[Category1]\\\")\\n    o.Categories.Push(\\\"[Category2]\\\")\\n    o.Categories.Push(\\\"[Category3]\\\")\\n    o.Actors = CreateObject(\\\"roArray\\\", 10, true)\\n    o.Actors.Push(\\\"[Actor1]\\\")\\n    o.Actors.Push(\\\"[Actor2]\\\")\\n    o.Actors.Push(\\\"[Actor3]\\\")\\n    o.Director = \\\"[Director]\\\"\\n    springBoard.SetContent(o)\\n    springBoard.Show()\\n    While True\\n        msg = wait(0, port)\\n        If msg.isScreenClosed() Then\\n            Return -1\\n        Elseif msg.isButtonPressed()\\n            print \\\"msg: \\\"; msg.GetMessage(); \\\"idx: \\\"; msg.GetIndex()\\n        Endif\\n    End While\\nEnd Function\\n</code></pre>\\n<p>The following screen is displayed when this code is executed:</p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/worddav256ada1e0e0cdc53d79428655ca7702b.png\\\" alt=\\\"worddav-code-displayed\\\" title=\\\"worddav256ada1e0e0cdc53d79428655ca7702b\\\"></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifspringboardscreen.md\\\" title=\\\"ifSpringboardScreen\\\">ifSpringboardScreen</a>                 </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a>                    </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rospringboardscreenevent.md\\\" title=\\\"roSpringboardScreenEvent\\\">roSpringboardScreenEvent</a>  </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rosprite.md":"{\n  \"content\": \"<h1 id=\\\"rosprite\\\">roSprite</h1>\\n<p>The roSprite object cannot be created directly with a CreateObject() call. It must be associated with a managing roCompositor object. This association is implicitly created by creating an roSprite object with the roCompositor methods NewSprite() or NewAnimatedSprite().</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsprite.md\\\" title=\\\"ifSprite\\\">ifSprite</a>              </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rostreamsocket.md":"{\n  \"content\": \"<h1 id=\\\"rostreamsocket\\\">roStreamSocket</h1>\\n<p>The roStreamSocket component enables BrightScript apps to accept and connect to TCP streams as well as send and receive data with them. The interface is modeled on and works much like standard Berkeley sockets.</p>\\n<p>This object is created without any arguments:</p>\\n<p><code>CreateObject(\\\"roStreamSocket\\\")</code></p>\\n<p><strong>Example: Open TCP Connection to Server</strong></p>\\n<pre><code>sendAddress = CreateObject(\\\"roSocketAddress\\\")\\nsendAddress.SetAddress(\\\"www.google.com:80\\\")\\nsocket = CreateObject(\\\"roStreamSocket\\\")\\nsocket.setSendToAddress(sendAddress)\\nIf socket.Connect()\\n    Print \\\"Connected Successfully\\\"\\nEnd If\\n</code></pre>\\n<p><strong>Example: Echo Server</strong></p>\\n<pre><code>function main()\\n    messagePort = CreateObject(\\\"roMessagePort\\\")\\n    connections = {}\\n    buffer = CreateObject(\\\"roByteArray\\\")\\n    buffer[512] = 0\\n    tcpListen = CreateObject(\\\"roStreamSocket\\\")\\n    tcpListen.setMessagePort(messagePort)\\n    addr = CreateObject(\\\"roSocketAddress\\\")\\n    addr.setPort(54321)\\n    tcpListen.setAddress(addr)\\n    tcpListen.notifyReadable(true)\\n    tcpListen.listen(4)\\n    if not tcpListen.eOK()\\n        print \\\"Error creating listen socket\\\"\\n        stop\\n    end if\\n    while True\\n        event = wait(0, messagePort)\\n        if type(event) = \\\"roSocketEvent\\\"\\n            changedID = event.getSocketID()\\n            if changedID = tcpListen.getID() and tcpListen.isReadable()\\n                ' New\\n                newConnection = tcpListen.accept()\\n                if newConnection = Invalid\\n                    print \\\"accept failed\\\"\\n                else\\n                    print \\\"accepted new connection \\\" newConnection.getID()\\n                    newConnection.notifyReadable(true)\\n                    newConnection.setMessagePort(messagePort)\\n                    connections[Stri(newConnection.getID())] = newConnection\\n                end if\\n            else\\n                ' Activity on an open connection\\n                connection = connections[Stri(changedID)]\\n                closed = False\\n                if connection.isReadable()\\n                    received = connection.receive(buffer, 0, 512)\\n                    print \\\"received is \\\" received\\n                    if received > 0\\n                        print \\\"Echo input: '\\\"; buffer.ToAsciiString(); \\\"'\\\"\\n                        ' If we are unable to send, just drop data for now.\\n                        ' You could use notifywritable and buffer data, but that is\\n                        ' omitted for clarity.\\n                        connection.send(buffer, 0, received)\\n                    else if received=0 ' client closed\\n                        closed = True\\n                    end if\\n                end if\\n                if closed or not connection.eOK()\\n                    print \\\"closing connection \\\" changedID\\n                    connection.close()\\n                    connections.delete(Stri(changedID))\\n                end if\\n            end if\\n        end if\\n    end while\\n\\n    print \\\"Main loop exited\\\"\\n    tcpListen.close()\\n    for each id in connections\\n        connections[id].close()\\n    end for\\nEnd Function\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketconnection.md\\\" title=\\\"ifSocketConnection\\\">ifSocketConnection</a>                   </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocket.md\\\" title=\\\"ifSocket\\\">ifSocket</a>                             </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketasync.md\\\" title=\\\"ifSocketAsync\\\">ifSocketAsync</a>                   </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketstatus.md\\\" title=\\\"ifSocketStatus\\\">ifSocketStatus</a>                        </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketconnectionstatus.md\\\" title=\\\"ifSocketConnectionStatus\\\">ifSocketConnectionStatus</a>              </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsocketconnectionoption.md\\\" title=\\\"ifSocketConnectionOption\\\">ifSocketConnectionOption</a>              </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rosocketevent.md\\\" title=\\\"roSocketEvent\\\">roSocketEvent</a>           </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rostring.md":"{\n  \"content\": \"<h1 id=\\\"rostring\\\">roString</h1>\\n<p>roString is the object equivalent for intrinsic type 'String'.</p>\\n<p>This is useful in the following situations:</p>\\n<ul>\\n<li>\\n<p>When an object is needed, instead of an intrinsic value. For example, \\\"roList\\\" maintains a list of objects. If an String is added to roList, it will be automatically wrapped in an roString by the language interpreter. When a function that expects a BrightScript Component as a parameter is passed a string, BrightScript automatically creates the equivalent BrightScript Component.</p>\\n</li>\\n<li>\\n<p>If any object exposes the ifString interface, that object can be used in any expression that expects an intrinsic value.</p>\\n</li>\\n</ul>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifstring.md\\\" title=\\\"ifString\\\">ifString</a>                </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifstringops.md\\\" title=\\\"ifStringOps\\\">ifStringOps</a>             </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftostr.md\\\" title=\\\"ifToStr\\\">ifToStr</a>                 </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rosystemlog.md":"{\n  \"content\": \"<h1 id=\\\"rosystemlog\\\">roSystemLog</h1>\\n<p>The roSystemLog component enables the application to receive events from the Roku Streaming Player that are intended for reporting errors and trends, rather than trigger a response to a user action.</p>\\n<p>All of the log event messages are sent to the roMessagePort that is registered on the <a href=\\\"/docs/references/brightscript/events/rosystemlogevent.md\\\" title=\\\"roSystemLogEvent\\\">roSystemLogEvent</a> object. See roSystemLogEvent for details on the messages.</p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roSystemLog\\\")</code></p>\\n<p>The roSystemLog component requires specific Design Patterns in your BrightScript Application. Take care to:</p>\\n<ul>\\n<li>Use one roMessagePort throughout the application (instead of creating a new roMessagePort for each screen).</li>\\n<li>Create one roSystemLog instance at startup that remains for the entire lifetime of the application.</li>\\n<li>Pass the global roMessagePort referenced in the first bullet point to SetMessagePort() on the roSystemLog component.</li>\\n<li>Enable the desired log types using EnableType().</li>\\n<li>Handle the <a href=\\\"/docs/references/brightscript/events/rosystemlogevent.md\\\" title=\\\"roSystemLogEvents\\\">roSystemLogEvents</a> in all message loops.</li>\\n</ul>\\n<p><strong>Example</strong></p>\\n<pre><code>Sub showVideoScreenWithLogging(item As Object)\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    vs = CreateObject(\\\"roVideoScreen\\\")\\n    ' **** Metrics *****\\n    ' Create a SystemLog object for detailed HTTP information and\\n    ' periodic bandwidth measurements. The high level idea is to use\\n    ' the roVideoScreen events as the primary driver of the\\n    ' reporting and then to use the http.error and http.connect\\n    ' roSystemLogEvents for detailed information. In this case that\\n    ' detailed information is primarily the ip addresses.\\n    syslog = CreateObject(\\\"roSystemLog\\\")\\n    syslog.SetMessagePort(port)\\n    syslog.EnableType(\\\"http.error\\\")\\n    syslog.EnableType(\\\"http.connect\\\")\\n    syslog.EnableType(\\\"bandwidth.minute\\\")\\n    ' **** End Metrics *****\\n    vs.SetContent(item)\\n    vs.SetPostionNotificationPeriod(1)\\n    vs.SetMessagePort(port)\\n    vs.Show()\\n    metrics = CreateObject(\\\"roAssociativeArray\\\")\\n    metrics.streamStartTimer = CreateObject(\\\"roTimespan\\\")\\n    metrics.timeSpentBuffering = 0\\n    metrics.errorCount = 0\\n    While True\\n        If msg.isPlaybackPosition() Then\\n            If metrics.streamStartTimer &#x3C;> invalid\\n                duration = metrics.streamStartTimer.TotalMilliseconds()\\n                dateTime = CreateObject(\\\"roDateTime\\\").asSeconds()*1000\\n                startTime = dateTime - duration\\n                note = \\\"Rebuferring\\\"\\n                if lastpos = 0 note =\\\"Initial loading\\\"\\n                print \\\"Report following prints via urls to your site\\\"\\n                print \\\"Note is \\\" ; note\\n                print \\\"Report startTime, buffering, duration, note\\\"\\n            End If\\n        Elseif type(msg) = \\\"roSystemLogEvent\\\" Then\\n             ' Handle the roSystemLogEvents:\\n             i = msg.GetInfo()\\n             If i.LogType = \\\"http.error\\\" or i.LogType = \\\"http.connect\\\"\\n                 If i.LogType = \\\"http.error\\\"\\n                     metrics.errorCount = metrics.errorCount + 1\\n                     print \\\"http error: \\\"; i.HttpCode; \\\"URL: \\\";i.Url\\n                 End If\\n                 url = i.OrigUrl\\n                 If (not httpIpAddrs.DoesExist(url)) Then\\n                     httpIpAddrs[url] = CreateObject(\\\"roAssociativeArray\\\")\\n                 End If\\n                 httpIpAddrs[url].AddReplace(i.TargetIp,\\\"\\\")\\n             Else If i.LogType = \\\"bandwidth.minute\\\"\\n                 metrics.bandwidth = i.Bandwidth\\n             End If\\n         End If\\n         REM more event handling\\n    End While\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsystemlog.md\\\" title=\\\"ifSystemLog\\\">ifSystemLog</a>            </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rotextscreen.md":"{\n  \"content\": \"<h1 id=\\\"rotextscreen\\\">roTextScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>roTextScreen provides a way of displaying large amounts of scrollable text.</p>\\n<p>This type of screen can be used to display help text, credits, license agreements, or other large amounts of text that require scrolling.</p>\\n<p>The interface allows you to set the text and specify zero or more buttons.</p>\\n<p>If no buttons are specified, then the user can exit the screen by pressing BACK or OK.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftextscreen.md\\\" title=\\\"ifTextScreen\\\">ifTextScreen</a>                    </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rotextscreenevent.md\\\" title=\\\"roTextScreenEvent\\\">roTextScreenEvent</a>   </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rotexttospeech.md":"{\n  \"content\": \"<h1 id=\\\"rotexttospeech\\\">roTextToSpeech</h1>\\n<blockquote>\\n<p>Please note this component is only available on the following devices: Roku Streaming Stick (3600X), Roku Express (3700X) and Express+ (3710X), Roku Premiere (4620X) and Premiere+ (4630X), Roku Ultra (4640X), and any Roku TV running Roku OS version 7.2 and later.</p>\\n</blockquote>\\n<p>The roTextToSpeech component provides text to speech capabilities to applications.</p>\\n<p>An roTextToSpeech component object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roTextToSpeech\\\")</code></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftexttospeech.md\\\" title=\\\"ifTextToSpeech\\\">ifTextToSpeech</a>                 </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rotexttospeechevent.md\\\" title=\\\"ifTextToSpeechEvent\\\">roTextToSpeechEvent</a>  </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rotexturemanager.md":"{\n  \"content\": \"<h1 id=\\\"rotexturemanager\\\">roTextureManager</h1>\\n<p>The Texture Manager provides a set of API's for managing an roBitmap cache.</p>\\n<p><strong>Example: Requesting an roBitmap from the roTextureManager</strong></p>\\n<pre><code>Sub Main()\\n    mgr = CreateObject(\\\"roTextureManager\\\")\\n    msgport = CreateObject(\\\"roMessagePort\\\")\\n    mgr.SetMessagePort(msgport)\\n\\n    request = CreateObject(\\\"roTextureRequest\\\",\\\"pkg:/assets/comet.jpg\\\")\\n    mgr.RequestTexture(request)\\n\\n    msg=wait(0, msgport)\\n    if type(msg)=\\\"roTextureRequestEvent\\\" then\\n        print \\\"request id\\\";msg.GetId()\\n        print \\\"request state:\\\";msg.GetState()\\n        print \\\"request URI:\\\";msg.GetURI()\\n        state = msg.GetState()\\n        if state = 3 then\\n            bitmap = msg.GetBitmap()\\n            if type(bitmap)&#x3C;>\\\"roBitmap\\\" then\\n                print \\\"Unable to create robitmap\\\"\\n                stop   ' stop exits to the debugger\\n            end if\\n        end if\\n   end if\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftexturemanager.md\\\" title=\\\"ifTextureManager\\\">ifTextureManager</a>                 </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a>   </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rotexturerequestevent.md\\\" title=\\\"roVideoPlayerEvent\\\">roTextureRequestEvent</a>  </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rotexturerequest.md":"{\n  \"content\": \"<h1 id=\\\"rotexturerequest\\\">roTextureRequest</h1>\\n<p>An roTextureRequest is used to make requests to the roTextureManager.</p>\\n<p>An roTextureRequest object is created using the CreateObject() method and passing it a URI string:</p>\\n<p><code>CreateObject(\\\"roTextureRequest\\\", \\\"pkg:/assets/comet.jpg\\\")</code></p>\\n<p><strong>Example: Requesting a URL from the roTextureManager</strong></p>\\n<pre><code>Sub Main()\\n    mgr = CreateObject(\\\"roTextureManager\\\")\\n    msgport = CreateObject(\\\"roMessagePort\\\")\\n    mgr.SetMessagePort(msgport)\\n\\n    request = CreateObject(\\\"roTextureRequest\\\",\\\"http://192.168.1.10/ball.png\\\")\\n    mgr.RequestTexture(request)\\n\\n    msg=wait(0, msgport)\\n    if type(msg)=\\\"roTextureRequestEvent\\\" then\\n        print \\\"request id\\\";msg.GetId()\\n        print \\\"request state:\\\";msg.GetState()\\n        print \\\"request URI:\\\";msg.GetURI()\\n        state = msg.GetState()\\n        if state = 3 then\\n            bitmap = msg.GetBitmap()\\n            if type(bitmap)&#x3C;>\\\"roBitmap\\\" then\\n                print \\\"Unable to create robitmap\\\"\\n                stop   ' stop exits to the debugger\\n            end if\\n        end if\\n   end if\\nEnd Sub\\n</code></pre>\\n<p><strong>Example: Requesting a scaled image from the roTextureManager</strong></p>\\n<pre><code>Sub Main()\\n    mgr = CreateObject(\\\"roTextureManager\\\")\\n    msgport = CreateObject(\\\"roMessagePort\\\")\\n    mgr.SetMessagePort(msgport)\\n\\n    request = CreateObject(\\\"roTextureRequest\\\",\\\"pkg:/assets/ball.png\\\")\\n    request.SetSize(100, 100)\\n    request.SetScaleMode(1)\\n    mgr.RequestTexture(request)\\nEnd Sub\\n</code></pre>\\n<p><strong>Example: Making an HTTPS request from the roTextureManager</strong></p>\\n<pre><code>Sub Main()\\n    mgr = CreateObject(\\\"roTextureManager\\\")\\n    msgport = CreateObject(\\\"roMessagePort\\\")\\n    mgr.SetMessagePort(msgport)\\n\\n    request = CreateObject(\\\"roTextureRequest\\\",\\\"https://192.168.1.10/ball.png\\\")\\n    request.SetCertificatesFile(\\\"common:/certs/ca-bundle.crt\\\")\\n    request.InitClientCertificates()\\n\\n    mgr.RequestTexture(request)\\nEnd Sub\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftexturerequest.md\\\" title=\\\"ifTextureRequest \\\">ifTextureRequest</a>                 </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a>           </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rotimespan.md":"{\n  \"content\": \"<h1 id=\\\"rotimespan\\\">roTimespan</h1>\\n<p>The Timespan object provides an interface to a simple timer for tracking the duration of activities. It's useful for tracking how an action has taken or if a specified time has elapsed from some starting event.</p>\\n<p><strong>Example: Timing an activity</strong></p>\\n<pre><code>REM ******************************************************\\nREM Compute the number of millisecs to perform a task\\nREM ******************************************************\\ntimer = CreateObject(\\\"roTimespan\\\")\\ntimer.Mark()\\nDoTimeConsumingTask()\\nPrint \\\"Task took: \\\" + timer.TotalMilliseconds().ToStr()\\n\\nREM ******************************************************\\nREM Compute how many seconds until rental expires\\nREM ******************************************************\\nFunction secondsLeft(String expirationDate) As Integer\\n    str = expirationDate\\n    if str = invalid return -1\\n    ts = CreateObject(\\\"roTimespan\\\")\\n    seconds = ts.GetSecondsToISO8601Date(str)\\n    print \\\"Expires: \\\" + str + \\\" secs: \\\" + Stri(seconds)\\n    return seconds\\nEnd Function\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iftimespan.md\\\" title=\\\"ifTimespan\\\">ifTimespan</a>             </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rourltransfer.md":"{\n  \"content\": \"<h1 id=\\\"rourltransfer\\\">roUrlTransfer</h1>\\n<p>A roUrlTransfer object transfers data to or from remote servers specified by URLs. It can perform mutual authentication with a web server.</p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roUrlTransfer\\\")</code></p>\\n<p>If using HTTPS, the developer must specify a certificate file by calling SetCertificatesFile() with a .pem file that includes the certificate authority cert (like Verisign, Thawte, etc., or your own with OpenSSL) that signed the web server certificate. This must be called before making a request. The developer can also use the Roku standard cert bundle (which contains certificates for most common signing authorities) stored in common:/certs/ca-bundle.crt; or download the CA certificate <a href=\\\"https://github.com/rokudev/ca-certificate/blob/master/ca-bundle.crt\\\">here</a>.</p>\\n<p>The web server can authenticate that the requested connection is from a Roku Streaming Player and that the request is from your application by taking the following actions:</p>\\n<ul>\\n<li>Add the Roku CA certificate to the web server's certificate authorities keychain, download the CA certificate.  </li>\\n<li>Configure your web server to reject any connection that does not have a valid client certificate.</li>\\n<li>Check the X-Roku-Reserved-Dev-Id header in the request. It should contain the Developer ID of your application. If it does not, another application on the Roku is attempting to access the server, and the request is rejected.</li>\\n</ul>\\n<p><strong>Example</strong></p>\\n<p>In order for your web server to perform the steps above to authenticate your Roku Streaming Player, your application needs to call the following functions before performing any https requests:</p>\\n<pre><code>object.SetCertificatesFile(\\\"common:/certs/ca-bundle.crt\\\")\\nobject.AddHeader(\\\"X-Roku-Reserved-Dev-Id\\\", \\\"\\\")\\nobject.InitClientCertificates()\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifurltransfer.md\\\" title=\\\"ifUrlTransfer\\\">ifUrlTransfer</a>                 </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a>                    </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rourlevent.md\\\" title=\\\"roUrlEvent\\\">roUrlEvent</a>  </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rovideoplayer.md":"{\n  \"content\": \"<h1 id=\\\"rovideoplayer\\\">roVideoPlayer</h1>\\n<p>The roVideoPlayer component implements a video player with more programmatic control, but less user control than the roVideoScreen component.</p>\\n<p>The roVideoPlayer can be used in conjunction with the roImageCanvas to do graphical overlays, windowed video, zoom, and programmatic control of playlists and trick play. When using with the roImageCanvas, you can put the roVideoPlayer is at a lower z-order layer than other imageCanvas layers and implement overlays on top of the playing video. </p>\\n<p>Unlike the roVideoScreen component roVideoPlayer does not have automatic trick play modes and built in controls to support that trick play. Any trick play requires the developer to build his own controls using buttons on the roImageCanvas. </p>\\n<p>Note that all the video playback notes under roVideoScreen apply to the roVideoPlayer. The customvideoplayer sample application is a good example of roVideoPlayer usage.</p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roVideoPlayer\\\")</code></p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifvideoplayer.md\\\" title=\\\"ifVideoPlayer\\\">ifVideoPlayer</a>                 </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a>                    </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rovideoplayerevent.md\\\" title=\\\"roVideoPlayerEvent\\\">roVideoPlayerEvent</a>              </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/rovideoscreen.md":"{\n  \"content\": \"<h1 id=\\\"rovideoscreen\\\">roVideoScreen</h1>\\n<blockquote>\\n<p>This component is deprecated and will be removed from Roku OS on January 1st, 2019.</p>\\n<p>Beginning July 1st, 2017, any new channels using this component will be rejected during certification.</p>\\n<p>Beginning January 1st, 2018, any updates to existing channels using this component will be rejected during certification.</p>\\n</blockquote>\\n<p>The Video Screen object implements the video playback portion of the user interface.</p>\\n<p>This object is created with no parameters:</p>\\n<p><code>CreateObject(\\\"roVideoScreen\\\")</code></p>\\n<p>The API's to the video screen allow the developer to setup a fully featured playback environment with minimal coding. The developer is responsible for initial playback setup and providing the required data (e.g. StreamURLs, SteamsBitrates, etc.) as part of the <a href=\\\"/docs/developer-program/getting-started/architecture/content-metadata.md\\\" title=\\\"Content Meta-Data\\\">Content Meta-Data</a>. Once created and displayed, the screen will respond to events and manage the playback experience for the user.</p>\\n<p>The roVideoScreen is designed for streaming content. The preferred implementation should provide multiple bitrates (ideally four) of video to provide a high quality user experience under a variety of network conditions. Using the StreamBitrates and StreamURLs provided in the content meta-data for the item, the roVideoScreen will automatically monitor and select the best stream based on the users measured bandwidth. If network performance changes, the system will adapt and rebuffer to stream at a different bandwidth if necessary. Note that the StreamURLs, StreamBitrates, StreamQualities and StreamStickyHttpRedirects are all arrays that are aligned with each other. For example, the first stream listed would be the 0th element of all of these arrays.</p>\\n<p>The bitrates should represent the actual bitrate of the stream. The bitrate is used for both the display of the dots as well as the stream selection algorithm. The dots work a follows; If the stream bitrate equals:</p>\\n<ul>\\n<li>0 = no dots</li>\\n<li>&#x3C; 500 Kbps= 1 dot</li>\\n<li>&#x3C; 800 Kbps = 2 dots</li>\\n<li>&#x3C;1.1 Mbps = 3 dots</li>\\n<li>\\n<blockquote>\\n<p>= 1.1 Mbps = 4 dots</p>\\n</blockquote>\\n</li>\\n</ul>\\n<p>The dots are displayed automatically based on the bitrate of the stream selected unless there is a single stream and the bitrate is set to zero, then it won't show any dots. The StreamQuality attribute is used to select streams and indicates if a stream is HD or not. If the attribute for HDBranded is set to true and the stream is HD, the HD icon will show beside the quality dots. If the StreamQuality is set to HD, and the user display type is set to SD, the HD stream will not be selected.</p>\\n<p>The roVideoScreen automatically provides trick mode for all supported content types. There are two type of trick modes supported; scene based selection and time-based selection. If BIF image files are provided for a title, scene-based trick modes will appear. (See the BIF File format Documentation for more information) The user will be presented with the images and progress bar needed for SEEK, FF, REW within a stream. The following image shows how trick modes are rendered with BIF files:</p>\\n<p><img src=\\\"https://image.roku.com/ZHZscHItMTc2/worddavdc8a50b63d70082736fbebee19c18eff.png\\\" alt=\\\"IMAGE\\\" title=\\\"worddavdc8a50b63d70082736fbebee19c18eff\\\"></p>\\n<p>The FF/REW functionality provides three speeds; slow, medium and fast. At slower speeds, the system displays the current frame in the center of the screen and additional frames on the side for contextual information. At higher speeds, the side frames disappear and only the center image is displayed. The I-frames within the video do not need to precisely align with the time stamp of the image frames in the BIF file. When the user stops and selects a frame, the video playback begins at the first I-frame less than or equal to the time position of the selected frame.</p>\\n<p>When BIF images are not available, the system will default to a time based trick play behavior. The user control is still the same, but only the progress bar is displayed and the user will not see individual scenes within the video. This mode is the default, so if images are not available for an individual title, the system will always provide this functionality by default.</p>\\n<p>The system will only seek to locations on an I-Frame boundary. Window Media (WMA9 or VC-1) uses the simple index object to determine the I-frame locations and H.264 uses the MOOV atom to determine the correct offsets. If the BIF images are at a consistent time intervals which do not align to I-Frame boundaries, the system will use the nearest I-Frame less than or equal to the time of the BIF image. MP4 or Windows Media are the preferred formats.</p>\\n<p><strong>Important Notes on Video Playback</strong></p>\\n<ul>\\n<li>\\n<p>The dimensions vary on a title-by-title basis depending on the source material and the target aspect ratio for the encode (e.g. 4:3 or 16:9).  Content is always encoded at full width and the height is adjusted.  For example, a 1.66 aspect ratio source is encoded as a 720x432 video and displayed as letterboxed for a 4:3 display.</p>\\n</li>\\n<li>\\n<p>The frame rate used for encoding is dependent on the source material. Film content is generally 23.976 fps, while video content is generally at 29.97.</p>\\n</li>\\n<li>\\n<p>For typical streaming video applications, we recommend a range of <sub>384Kbps to </sub>4.5Mbps. For USB playback, we recommend that you stay under 8.0 Mbps. This provides a good balance between quality and support for a wide number of users. In some cases lower and higher bitrates have been used, but this frequently results in poor quality or limits the % of the installed base that can view this encoding.</p>\\n</li>\\n<li>\\n<p>It is critical that the StreamURLs, StreamBitrates, StreamQualities and StreamStickyHttpRedirects arrays are all aligned with each other. For example, the first stream listed would be the 0th element of all of these arrays. You may have multiple streams in the arrays and the system will automatically pick the most appropriate stream based on the users available bandwidth and video settings.</p>\\n</li>\\n<li>\\n<p>The StreamQualities array identifies streams as either SD or HD. If the user is configured for SD the system will not select HD streams for playback.</p>\\n</li>\\n<li>\\n<p>The optional StreamStartTimeOffset is the offset into the stream which is considered to be the new origin of playback.</p>\\n</li>\\n<li>\\n<p>Live  declares the video as live and replaces the time remaining text in the progress bar with \\\"live\\\".</p>\\n</li>\\n<li>\\n<p>HLS Http Live Streaming support is included in the Roku OS (Introduced in Roku OS2.6). We currently support version 3 of the Http Live Streaming protocol (Pantos  Draft submitted to IETF November 19, 2010 <a href=\\\"http://tools.ietf.org/html/draft-pantos-http-live-streaming-05\\\">http://tools.ietf.org/html/draft-pantos-http-live-streaming-05</a> ). When using HLS, the StreamUrls and StreamQualities array should each have exactly one element.  If the HLS stream has only a single bitrate stream, the StreamBitrates array should contain one element specifying that bitrate.  If the stream contains more than one variant stream at multiple bitrates, the StreamBitrates array should contain one element with a value of zero. Please see the Video Encoding Guide for information about creating HLS .m3u8 files and segmented .ts files from your current h264 encoded video or distributing live video over HLS to the Roku box.</p>\\n</li>\\n<li>\\n<p>In addition to the support for version 2 of the HLS Pantos draft spec, the Roku box supports .m3u8 files that are compressed via deflate or gzip.</p>\\n<ul>\\n<li>The HTTP response for a query that returns a gzip-compressed file must contain the header: Content-Encoding: gzip</li>\\n<li>The HTTP response for a query that returns a deflate-compressed file must contain the header: Content-Encoding: deflate</li>\\n</ul>\\n</li>\\n<li>\\n<p>\\\"Trick Modes\\\" and seeking work a little differently with HLS streams. There are a couple of ways that seeking works with HLS and they are different than other streams.</p>\\n<p>  One way of seeking uses the \\\"target duration\\\" specified in the .m3u8 file. The first segment in an m3u8 file is assigned a time offset:</p>\\n<p>  T = G * N</p>\\n<p>  where G is the \\\"target duration\\\" value and N is the sequence number of the segment. Each subsequent segment is assigned a time offset equal to T (the time offset of the first segment) plus the duration value of all earlier segments. The duration of a segment is determined by the EXTINF line before that segment.</p>\\n</li>\\n<li>\\n<p>Smooth Streaming (since v4.7) and later by setting the StreamFormat to \\\"ism\\\" and setting the streamURL to the MANIFEST url.</p>\\n<ul>\\n<li>The player type (ContentMetaData.StreamFormat) is \\\"ism\\\"</li>\\n<li>The stream URL is the URL that points to the manifest</li>\\n<li>Only H.264 and/or AAC encoding formats are currently supported.</li>\\n<li>Only direct PlayReady licensing is supported. Indirect licensing is currently unsupported. That is, for decryption to work, the ProtectionHeader must be available in the manifest and the LA_URL should contain a valid URL to an accessible PlayReady license server.</li>\\n<li>If there are multiple audio tracks, a track will be chosen based on the StreamIndex.Language attribute in the manifest. If the StreamIndex.Language attribute is not populated, the audio track will be chosen arbitrarily. To select a specific audio track before playback, set the ContentMetaData.TrackIDAudio field to the desired track's StreamIndex.Name attribute.</li>\\n<li>If there are multiple video tracks, a track will be chosen arbitrarily. To select a specific video track before playback, set the ContentMetaData.TrackIDVideo field to the desired track's StreamIndex.Name attribute.</li>\\n</ul>\\n</li>\\n<li>\\n<p>Standard PlayReady SDK 2.0 Direct License Acquisition Over-the-Air (since v4.8) works by reading the Rights Management Protection Header in the Smooth Streaming Manifest Url.  The Roku OS retrieves the license from the PlayReady license server at the license acquisition url endpoint in the Protection Header.</p>\\n</li>\\n</ul>\\n<pre><code>#EXT-X_TARGETDURATION:10\\n#EXT-X-MEDIA-SEQUENCE:37\\n#EXTINF:10\\nurl1\\n#EXTINF:8\\nurl2\\n#EXTINF:10\\nurl3\\n</code></pre>\\n<p>The segment url1 has a time offset of 370, url2 is 380, and url3 is 388. Note that if no TARGETDURATION is specified, the default is 1, so the first segment in the file will have a nonzero time offset (equal to the target duration). The PlayStart content-meta data value allows direct seeking to an offset that is valid within the window of data in the current .m3u8 file.</p>\\n<p>There is a second way to seek in an HLS stream. If the m3u8 file has #EXT-X-PROGRAM-DATE-TIME entries, you can seek to a particular date/time by passing a value equal to a modified Unix epoch value. The modified epoch is 1/1/2004 rather than the standard Unix epoch of 1/1/1970. A Unix time value can be converted to an HLS seek time by subtracting 1072915200 (the number of seconds between 1/1/1970 and 1/1/2004). Once again, setting the PlayStart content meta data value allows direct seeking to a specific time offset.</p>\\n<p>For example, to seek to the segment marked with the date/time of 7/4/2010 11:30, set PlayStart to 205327800. An example shell expression showing this arithmetic is:</p>\\n<pre><code>% expr `date -d \\\"7/4/2010Z11:30:00.000\\\" +%s` - 1072915200\\n205327800\\n</code></pre>\\n<p>In BrightScript, the same calculation might be:</p>\\n<pre><code>dt = CreateObject(\\\"roDateTime\\\")\\ndt.fromISO8601String(\\\"7/4/2010T11:30:00.000\\\")\\nitemContentMetaData.PlayStart = dt. asSeconds() - 1072915200 '205327800\\n</code></pre>\\n<ol>\\n<li>\\n<p>In Roku OS version 2.6, we've introduced support for SRT files. Please see the content meta-data parameter SubtitleUrl for pointing to a matching SRT file for your video content.</p>\\n</li>\\n<li>\\n<p>In Roku OS version 2.7, we've introduced 1080p support. Please see the content meta-data parameter FullHD for specifying 1080p resolution. Playback at 1080p resolution will only occur when the user has set the display type to HDTV 1080p. Another content meta-data parameter, FrameRate, specifies the frames per second of the video. Valid values are 24 and 30. If the user's display type is set to 1080p and FullHD for the content is false or not set, HD playback will be at 720p resolution. If the user's display type is set to HDTV 720p and FullHD content is set to 1080p resolution, the box will downscale the content to 720p resolution.</p>\\n</li>\\n</ol>\\n<p><strong>Example</strong></p>\\n<pre><code>'**********************************************************************\\n' This example function is passed an associative array representing a ' piece of content (e.g. a TV episode) There are other attributes\\n' (title, description, etc.) but this example focuses on showing\\n' attributes required for initiating playback. It creates a video\\n' screen, sets the content and starts playback by calling Show()\\n'**********************************************************************\\nFunction showVideoScreen(episode As Object)\\n    if type(episode) &#x3C;> \\\"roAssociativeArray\\\" then\\n        print \\\"invalid data passed to showVideoScreen\\\"\\n        return -1\\n    endif\\n    port = CreateObject(\\\"roMessagePort\\\")\\n    screen = CreateObject(\\\"roVideoScreen\\\")\\n   ' Note: HDBranded controls whether the \\\"HD\\\" logo is displayed for a\\n   '       title. This is separate from IsHD because its possible to\\n' have an HD title where you don't want to show the HD logo\\n' branding for the title. Set these two as appropriate for\\n' your content\\n   episode.HDBranded = false\\n   episode.IsHD = false\\n   ' Note: The preferred way to specify stream info in v2.6 is to use\\n' the Stream roAssociativeArray content meta data parameter.\\n\\nepisode.Stream = { url:\\\"http://myserver.mydomain.com/mycontent.mp4\\\",\\nbitrate:2000\\nquality:false\\ncontentid:\\\"mycontent-2000\\\"\\n}\\nepisode.StreamFormat: \\\"mp4\\\"\\n   ' now just tell the screen about the title to be played, set the\\n   ' message port for where you will receive events and call show to\\n   ' begin playback.  You should see a buffering screen and then\\n   ' playback will start immediately when we have enough data buffered.\\n    screen.SetContent(episode)\\n    screen.SetMessagePort(port)\\n    screen.Show()\\n   ' Wait in a loop on the message port for events to be received.\\n   ' We will just quit the loop and return to the calling function\\n   ' when the users terminates playback, but there are other things\\n   ' you could do here like monitor playback position and see events\\n   ' from the streaming player.  Look for status messages from the video\\n   ' player for status and failure events that occur during playback\\n    while true\\n       msg = wait(0, port)\\n\\n       if type(msg) = \\\"roVideoScreenEvent\\\" then\\n           print \\\"showVideoScreen | msg = \\\"; msg.GetMessage() \\\" | index = \\\"; msg.GetIndex()\\n           if msg.isScreenClosed()\\n               print \\\"Screen closed\\\"\\n               exit while\\n            else if msg.isStatusMessage()\\n                  print \\\"status message: \\\"; msg.GetMessage()\\n            else if msg.isPlaybackPosition()\\n                  print \\\"playback position: \\\"; msg.GetIndex()\\n            else if msg.isFullResult()\\n                  print \\\"playback completed\\\"\\n                  exit while\\n            else if msg.isPartialResult()\\n                  print \\\"playback interrupted\\\"\\n                  exit while\\n            else if msg.isRequestFailed()\\n                  print \\\"request failed - error: \\\"; msg.GetIndex();\\\" - \\\"; msg.GetMessage()\\n                  exit while\\n            end if\\n       end if\\n    end while\\nEnd Function\\n</code></pre>\\n<h4 id=\\\"closed-captions\\\">Closed captions</h4>\\n<p>roVideoScreen supports a variety of options for displaying closed captions. Refer to <a href=\\\"/docs/specs/media/streaming-specifications.md\\\" title=\\\"Closed Caption Support\\\">Closed Caption Support</a> for complete details.</p>\\n<h4 id=\\\"id3-tag-support\\\">ID3 Tag Support</h4>\\n<p>The 5.2 firmware release added ID3 tag support to the Roku platform to provide access to timed metadata that may be included in ausio and video streams.  In addition to roVideoScreen, support for ID3 tags is also available in roVideoPlayer and roAudioPlayer.  Timed metadata is used to embed information such as ad tracking beacons, links to additional information about the content being played such as IMDB entries of movies, player stats in sports channels, current song album art, or any other metadata with associated timecodes that match the audio or video.  Roku supports ID3 tags in HLS, Smooth Streams, MPEG-4 video and MP3 audio.</p>\\n<p>A BrightScript channel registers its interest ID3 tags in a stream by calling the SetTimedMetaDataForKeys() function defined on the ifVideoScreen, ifVideoPlayer, and ifAudioPlayer interfaces.  The channel passes an array of metadata key names to this function that corresponds to the set of metadata the channel wants to read.  When the PTS timecode of an ID3 tag equals the current PTS, the video or audio player component fires an isTimedMetaData() event which contains the details of the metadata.  See <a href=\\\"/docs/references/brightscript/events/rovideoplayerevent.md\\\" title=\\\"roVideoPlayerEvent\\\">roVideoPlayerEvent</a> and <a href=\\\"/docs/references/brightscript/interfaces/ifvideoscreen.md#settimedmetadataforkeyskeys-as-dynamic-as-void\\\" title=\\\"SetTimedMetaDataForKeys\\\">SetTimedMetaDataForKeys</a> for details.</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifvideoscreen.md\\\" title=\\\"ifVideoScreen\\\">ifVideoScreen</a>                 </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifhttpagent.md\\\" title=\\\"ifHttpAgent\\\">ifHttpAgent</a>                    </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifsetmessageport.md\\\" title=\\\"ifSetMessagePort\\\">ifSetMessagePort</a>               </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifgetmessageport.md\\\" title=\\\"ifGetMessagePort\\\">ifGetMessagePort</a>               </li>\\n</ul>\\n<h2 id=\\\"supported-events\\\">Supported events</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/events/rovideoscreenevent.md\\\" title=\\\"roVideoScreenEvent\\\">roVideoScreenEvent</a>              </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roxmlelement.md":"{\n  \"content\": \"<h1 id=\\\"roxmlelement\\\">roXMLElement</h1>\\n<p>roXMLElement is used to contain an XML tree. </p>\\n<p>For instance,</p>\\n<pre><code>&#x3C;tag1>this is some text&#x3C;/tag1>\\n</code></pre>\\n<p>Would parse such that:</p>\\n<pre><code>    Name = \\\"tag1\\\"\\n    Attributes = invalid\\n    Body = roString with \\\"this is some text\\\"\\n</code></pre>\\n<p><strong>Example</strong></p>\\n<pre><code>&#x3C;emptytag caveman=\\\"barney\\\" /> \\n</code></pre>\\n<p>Would parse such that:</p>\\n<pre><code>    Name = \\\"emptytag\\\"\\n    Attributes = roAssociativeArray, with one entry { caveman: \\\"barney\\\" }\\n    Body = invalid\\n</code></pre>\\n<p>If the tag contains other tags, body will be of type roXMLList. </p>\\n<p>To generate XML, create an roXMLElement, then use functions like SetName(), AddAttribute(), SetBody(), AddElementWithBody(), AddElement(), AddBodyElement(), and AddText() functions to build the XML object hierarchy.</p>\\n<p>Then call GenXML() to return the XML as a string.</p>\\n<p>GenXML() takes one parameter (boolean) that indicates whether the generated xml should have the &#x3C;?xml > tag at the top.</p>\\n<p><strong>Example: Subroutine to print out the contents of an roXMLElement tree</strong></p>\\n<pre><code>PrintXML(root, 0)\\n\\nSub PrintXML(element As Object, depth As Integer)\\n    print tab(depth*3);\\\"Name: \\\";element.GetName()\\n    if not element.GetAttributes().IsEmpty() then\\n        print tab(depth*3);\\\"Attributes: \\\";\\n        for each a in element.GetAttributes()\\n            print a;\\\"=\\\";left(element.GetAttributes()[a], 20);\\n            if element.GetAttributes().IsNext() then print \\\", \\\";\\n        end for\\n        print\\n    end if\\n    if element.GetText()&#x3C;>invalid then\\n        print tab(depth*3);\\\"Contains Text: \\\";left(element.GetText(), 40)\\n    end if\\n    if element.GetChildElements()&#x3C;>invalid\\n        print tab(depth*3);\\\"Contains roXMLList:\\\"\\n        for each e in element.GetChildElements()\\n            PrintXML(e, depth+1)\\n        end for\\n    end if\\n    print\\nend sub\\n</code></pre>\\n<p><strong>Example: Generating XML</strong></p>\\n<pre><code>root.SetName(\\\"myroot\\\")\\nroot.AddAttribute(\\\"key1\\\", \\\"value1\\\")\\nroot.AddAttribute(\\\"key2\\\", \\\"value2\\\")\\nne = root.AddBodyElement()\\nne.SetName(\\\"sub\\\")\\nne.SetBody(\\\"this is the sub1 text\\\")\\nne = root.AddBodyElement()\\nne.SetName(\\\"subelement2\\\")\\nne.SetBody(\\\"more sub text\\\")\\nne.AddAttribute(\\\"k\\\", \\\"v\\\")\\nne = root.AddElement(\\\"subelement3\\\")\\nne.SetBody(\\\"more sub text 3\\\")\\nroot.AddElementWithBody(\\\"sub\\\", \\\"another sub (#4)\\\")\\nPrintXML(root, 0)\\nprint root.GenXML(false)\\n</code></pre>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifxmlelement.md\\\" title=\\\"ifXMLElement\\\">ifXMLElement</a>        </li>\\n</ul>\"\n}","https://developer.roku.com/api/v1/get-dev-cms-doc?locale=en-us&filePath=references/brightscript/components/roxmllist.md":"{\n  \"content\": \"<h1 id=\\\"roxmllist\\\">roXMLList</h1>\\n<p>Contains a list of roXML objects.</p>\\n<p>Normally roXMLList objects are not created via CreateObject(), but are returned from various ifXMLElement functions such as GetChildElements() and GetBod</p>\\n<h2 id=\\\"supported-interfaces\\\">Supported interfaces</h2>\\n<ul>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iflist.md\\\" title=\\\"ifList\\\">ifList</a>                    </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/ifxmllist.md\\\" title=\\\"ifXMLList\\\">ifXMLList</a>                  </li>\\n<li><a href=\\\"/docs/references/brightscript/interfaces/iflisttoarray.md\\\" title=\\\"ifListToArray\\\">ifListToArray</a>             </li>\\n</ul>\"\n}"}
